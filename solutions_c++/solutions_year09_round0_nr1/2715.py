#include <iostream>
#include <fstream>
#include <cstring>
#include <iomanip>
#include <string>
#include <vector>
#include <list>
using namespace std;

#include <stdio.h>
#include <stdlib.h>
int main()
{

    // FILE *inF = fopen("i:\\timepasscoding\\watershed_09\\B-small-attempt0.txt", "r");
    FILE *inF = fopen("i:\\timepasscoding\\alien_lang\\A-large.in", "r");
    //FILE *outF = fopen("i:\\timepasscoding\\alien_lang\\out.txt", "r");
    ofstream outF;
    outF.open("i:\\timepasscoding\\alien_lang\\out_large.txt");
    int Cases = 0;
    int L = 0;
    int D = 0;

    char c = '\0';
    fscanf(inF, "%d %d %d\n", &L, &D, &Cases);
    vector<string> s;
    string s1,s2;
    vector<vector<string>> states(Cases);
    vector<string> tokens;
    
    for (int iStrs = 0; iStrs < D; iStrs++)
    {
        s1.clear();
        for (int iLen = 0; iLen < L; iLen++)
        {
            c = fgetc(inF);
            if (c == '\n' || c == '\r')
                c = fgetc(inF);
            s1.push_back(c);
        }
        s.push_back( s1);
    }

    // cout<<"dictionary read"<<endl;
    c = fgetc(inF);
    while (c == '\n' || c == '\r')
        c = fgetc(inF);
    int iCases = 0;
    while(iCases < Cases && !feof(inF))
    {
        s2.clear();
        if (c == '(')
        {
            
            while (c!= ')')
            {
                c = fgetc(inF);
                if (c == ')')
                    break;
                else
                    s2.push_back(c);
            }
            states[iCases].push_back(s2);
        }
        //if (c == ')')
        //state complete
        else
        {
            s2.push_back(c);
            states[iCases].push_back(s2);
        }
        c = fgetc(inF);
        if (c == '\n' || c == '\r' || c == -1)
        {
            int iStringMatch = 0;
            // one case read, execute!!!
            {
                bool bLetterMatch = false;
                bool bFailPattern = false;
                
                int iTestPattern = 0;
                int iTestL = 0;
                int i = 0;
                for (iTestPattern = 0; iTestPattern < D; iTestPattern++)
            {
                iTestL = 0;
                bFailPattern = false;
                while(iTestL < L && !bFailPattern)
                {
                    int sets = states[iCases].size();
                    for (i = 0; i < sets; i++)
                    {
                        bLetterMatch = false;
                        bFailPattern = false;
                        int letters = states[iCases][i].size();
                        for (int j = 0; j < letters; j++)
                        {
                            string test1 = s[iTestPattern];
                            char c2 = states[iCases][i][j];
                            if (test1[iTestL] == c2)
                            {
                                // next letter from testpattern, next state
                                iTestL++;
                                bLetterMatch = true;
                                break;
                            }
                            if (!bLetterMatch)
                            {
                                // This pattern cannot be generated by this set
                                //break;
                            }
                        }
                        if (!bLetterMatch)
                        {
                            // This pattern cannot be generated by this set
                            bFailPattern = true;
                            break;
                        }
                    }
                }
                if (bLetterMatch)
                    iStringMatch++;
                //else
                // cout << "Cant generate pattern #"<<iTestPattern<<" from "<<i<<"th lexicon"<<endl;
            }
            }
            iCases++;
            if (!feof(inF))
                c = fgetc(inF);
            outF<<"Case #"<<iCases<<": "<<iStringMatch<<endl;
            // cout<<"Case #"<<iCases<<": "<<iStringMatch<<endl;
        }
    }
        // try strings
        
        // first char
        // put in first state, if matches required tokens, get next char and use next state
    
        // else get next char and try same state
        // if string exhausted, fail
        // if reach final state, count++
fclose(inF);
    return 0;
    
}