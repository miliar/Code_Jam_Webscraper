/**
 * New Lottery Game
 * 
 * The Lottery is changing! The Lottery used to have a machine to generate a random winning number. But due to cheating problems, the Lottery has decided to add another machine. The new winning number will be the result of the bitwise-AND operation between the two random numbers generated by the two machines.
 * 
 * To find the bitwise-AND of X and Y, write them both in binary; then a bit in the result in binary has a 1 if the corresponding bits of X and Y were both 1, and a 0 otherwise. In most programming languages, the bitwise-AND of X and Y is written X&Y.
 * 
 * For example:
 *    The old machine generates the number 7 = 0111.
 *    The new machine generates the number 11 = 1011.
 *    The winning number will be (7 AND 11) = (0111 AND 1011) = 0011 = 3.
 * 
 * With this measure, the Lottery expects to reduce the cases of fraudulent claims, but unfortunately an employee from the Lottery company has leaked the following information: the old machine will always generate a non-negative integer less than A and the new one will always generate a non-negative integer less than B.
 * 
 * Catalina wants to win this lottery and to give it a try she decided to buy all non-negative integers less than K.
 * 
 * Given A, B and K, Catalina would like to know in how many different ways the machines can generate a pair of numbers that will make her a winner.
 * 
 * Could you help her?
 * 
 * 
 * Input
 * 
 * The first line of the input gives the number of test cases, T. T lines follow, each line with three numbers A B K.
 * 
 * Output
 * 
 * For each test case, output one line containing "Case #x: y", where x is the test case number (starting from 1) and y is the number of possible pairs that the machines can generate to make Catalina a winner.
 * 
 * Limits
 * 
 * 1 ≤ T ≤ 100.
 * 
 * Small dataset
 * 
 * 1 ≤ A ≤ 1000.
 * 1 ≤ B ≤ 1000.
 * 1 ≤ K ≤ 1000.
 * 
 * Large dataset
 *
 * 1 ≤ A ≤ 109.
 * 1 ≤ B ≤ 109.
 * 1 ≤ K ≤ 109.
 */

#include <iostream>

using namespace std;

size_t GetPossiblePairs(size_t A, size_t B, size_t K)
{
	size_t result = 0;
	for (size_t pA = 0; pA < A; ++pA)
		for (size_t pB = 0; pB < B; ++pB)
		{
			if ((pA&pB) < K) 
			{
				//cerr << "A("<<pA<<")&B("<<pB<<")=" << (pA&pB) << "<K(" << K << ")"<< endl; 
				++result;
			}
		}
	return result;
}

size_t GetHighestValue(size_t number)
{
	size_t number_of_bits = 0;
	while(number)
	{
		number >>= 1;
		++number_of_bits;
	}
	return number_of_bits;
}

int main(int argc, char **argv)
{
	size_t number_of_test_cases;
	cin >> number_of_test_cases;
	
	for (size_t test_case_number = 0; test_case_number < number_of_test_cases; ++test_case_number)
	{
		size_t A, B, K;
		cin >> A >> B >> K;
		
		cerr << "==========" << endl << "Case #" << test_case_number + 1 << ": " << endl;
		cerr << "A=" << A << ", B=" << B << ", K=" << K << endl;

		size_t result = GetPossiblePairs(A, B, K);
		
		cout << "Case #" << test_case_number + 1 << ": " << result << endl;
		cerr << "The result is " << result << endl << "==========" << endl;
	}
	
	return number_of_test_cases;
}

