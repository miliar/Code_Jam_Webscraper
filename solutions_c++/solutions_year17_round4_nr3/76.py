/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Majk
 */

#include <vector>
#include <iostream>
#include <unordered_map>
#include <map>
#include <iomanip>
#include <set>
#include <functional>
#include <fstream>
#include <algorithm>
#include <cassert>
#include <cmath>
#include <string>
#include <sstream>
#include <queue>
using namespace std;

#define x first
#define y second
constexpr int MOD = 1000000007;

typedef std::pair<int,int> pii;
typedef long long ll;
typedef unsigned int ui;

template<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}
template<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {for(size_t i=0;i<t.size();++i){o<<t[i]<<" \n"[i == t.size()-1];}return o;}
template <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}
template<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;
template<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;
auto fraclt = [](const pii&a,const pii&b) { return (ll)a.x * b.y < (ll)b.x * a.y; };
struct cmpfrac { bool operator()(const pii&a,const pii&b)const { return (ll)a.x * b.y < (ll)b.x * a.y; }};


struct input {
	std::istream &cin;
	explicit input(std::istream &cin) :cin(cin){}
	template <typename T> operator T() { T t; cin >> t; return t; }
};
#define $ input{cin}

int logceil(ll x) {int b=0;while(x){x>>=1;++b;}return b;}

namespace std {
    template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}};
}
template<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}
template<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}
template<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }

template<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};
template<typename T>class vector3:public vector<vector<vector<T>>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector<vector<T>>>(a,vector<vector<T>>(b,vector<T>(c,t))){}};

// #include "../l/mod.h"
#include <thread>

struct twosat {
	twosat(const vector<vector<int>>&E) : N(E.size()), G(E), Grev(N), visited(N, false), leader(N, 0), finish(N, 0), order(N, 0), t(0) {
		for (int i = 0; i < N; ++i) {
			for (int v: G[i]) {
				Grev[v].push_back(i);
			}
		}
	}

	int N;
	vector<vector<int>> G, Grev;
	vector<bool> visited;
	vector<int> leader,finish,order;
	int t;
	map <int, bool> ass;

	void dfs_reverse(int i) {
		visited[i] = true;
		for (auto v: Grev[i]) if(!visited[v]) dfs_reverse(v);
		finish[i] = t++;
	}

	void dfs(int i, int parent) {
		visited[i] = true;
		leader[i] = parent;
		for (auto v: G[i]) if(!visited[v]) dfs(v, parent);
	}

	bool stronglyConnected(int u, int v) { return leader[u] == leader[v]; }

	bool run() {

		fill(visited.begin(), visited.end(), false);
		for (int i = N-1; i >= 0; i--) {
			if (!visited[i])
				dfs_reverse(i);
			order[finish[i]] = i;
		}

		fill(visited.begin(), visited.end(), false);
		for (int i = N-1; i >= 0; i--)
			if (!visited[order[i]]) {
				dfs(order[i], order[i]);
			}


		cerr << order;
		cerr << leader;
		bool ok = true;
		for (int i = N-1; i >= 0; i--) {
			int u = order[i];
			if (u >= N/2) {
				if (stronglyConnected(u, u - N/2)) { cerr << u << " strongly conn" << endl; return false; }
				if (ass.find(leader[u]) == ass.end()) {
					ass[leader[u]] = true;
					ass[leader[u - N/2]] = false;
				}
			} else {
				if (stronglyConnected(u, N/2 + u)) { cerr << u << " strongly conn" << endl; return false; }
				if (ass.find(leader[u]) == ass.end()) {
					ass[leader[u]] = true;
					ass[leader[N/2 + u]] = false;
				}
			}
		}


		return true;

	}
};

class TaskC {
public:
    struct Calc {
		int R,C;
		vector<string> V;
		vector2<int> I;
		vector2<vector<pair<int,bool>>> O;
		vector<pair<bool, bool>> Valid;
		bool possible;
		vector<int> Ans;

		void explore(int i, int R, int C, int DR, int DC) {
			vector<pii> P;
			int r = R, c = C, dr = DR, dc = DC;
//			cerr << "explore " << R << ' ' << C << ' ' << (bool)DR << endl;

			while (true) {
				r += dr;
				c += dc;
				// cerr << "go to " << r << ' ' << c << V[r][c] << endl;

				if (r < 0 || r >= this->R || c < 0 || c >= this->C) { break; }
				if (V[r][c] == '#') { break; }
				else if (V[r][c] == '.') { P.push_back({r,c}); }
				else if (V[r][c] == '-' || V[r][c] == '|') {
					if (DR) Valid[i].x = false;
					else Valid[i].y = false;
					cerr << "laser" << R << ' ' << C << ' ' << r << ' ' << c << ' ' << DR << endl;
					return;
				} else if (V[r][c] == '/') {
//					cerr << dr << ' ' << dc << " to ";
					swap(dr,dc); dc = -dc; dr = -dr;
//					cerr << dr << ' ' << dc;
				} else if (V[r][c] == '\\') {
					swap(dr,dc);
				}
			}

//			cerr << "explore done" << endl;
			for (pii &p: P) {
				O[p.x][p.y].push_back({i, DR});
			}
		}


        void calc() {
			possible = true;
			I = vector2<int>(R,C, -1);
			O = vector2<vector<pair<int,bool>>>(R,C);
			int lasers = 0;
			for (int r = 0; r < R; ++r) {
				for (int c = 0; c < C; ++c) {
					if (V[r][c] == '-' || V[r][c] == '|') {
						I[r][c] = lasers++;
					}
				}
			}

			Valid = vector<pair<bool,bool>>(lasers, {true,true});

			for (int r = 0; r < R; ++r) {
				for (int c = 0; c < C; ++c) {
					if (V[r][c] == '-' || V[r][c] == '|') {
						explore(I[r][c], r, c, -1, 0);
						explore(I[r][c], r, c, 1, 0);
						explore(I[r][c], r, c, 0, 1);
						explore(I[r][c], r, c, 0, -1);
					}
				}
			}

			vector<vector<int>> E(2*lasers);

			for (int r = 0; r < R; ++r) {
				for (int c = 0; c < C; ++c) {
					if (V[r][c] == '.') {
						if (O[r][c].size() == 0) { possible = false; return; }
						else if (O[r][c].size() == 1) {
							if (O[r][c][0].y) {
								Valid[O[r][c][0].x].y = false;
							} else {
								Valid[O[r][c][0].x].x = false;
							}
						} else {
							auto a = O[r][c][0];
							auto b = O[r][c][1];
							E[a.x + lasers*(a.y)].push_back(b.x + lasers*(1 - b.y));
							E[b.x + lasers*b.y].push_back(a.x + lasers*(1-a.y));
						}
					}
				}
			}

			for (int i = 0; i < lasers; ++i) {
				if (Valid[i] == pair<bool,bool>{false,false}) { possible = false; return; }
				if (!Valid[i].x) { E[i].push_back(i+lasers); }
				if (!Valid[i].y) { E[i+lasers].push_back(i); }
			}

			twosat S{E};
			possible = S.run();
			if (possible) {
				Ans.resize(lasers);
				for (int i = 0; i < lasers; ++i) {
					Ans[i] = S.ass[S.leader[i]];
				}
			}
        }

        void read(istream& cin) {
        	cin >> R >> C;
			V.resize(R);
			cin >> V;
		}

        void write(ostream &cout) {
			if (!possible) {
				cout << "IMPOSSIBLE\n";
			} else {
				cout << "POSSIBLE\n";
				for (int r = 0; r < R; ++r) {
					for (int c = 0; c < C; ++c) {
						if (V[r][c] == '|' || V[r][c] == '-') {
							cout << "-|"[Ans[I[r][c]]];
						} else {
							cout << V[r][c];
						}
					}
					cout << "\n";
				}
			}
        }

        std::thread th;
    };


    vector<Calc> C;
	void solve(istream& cin, ostream& cout) {
        int T; cin >> T; C.resize(T);
		for (int t = 0; t < T; ++t) {
			Calc *c = &C[t];
			c->read(cin);
			//c->th = std::thread{[=]() mutable {c->calc();}};
			c->calc();
		}

		for (int t = 0; t < T; ++t) {
		    // C[t].th.join();
            cout << "Case #" << t+1 << ": ";
			C[t].write(cout);
		}
	}
};

#include <dirent.h>
#include <stdexcept>
#include <regex>
#include <sys/stat.h>
#include <cstdint>

std::string getLastFileName(const std::string& regexString) {
	DIR* dir;
	dirent* entry;
	std::string result = "";
	int64_t resultModificationTime = 0;
	std::regex regex(regexString);
	if ((dir = opendir (".")) != NULL) {
		while ((entry = readdir (dir)) != NULL) {
			if (std::regex_match(entry->d_name, regex)) {
				struct stat buffer;
				stat(entry->d_name, &buffer);
				int64_t modificationTime = static_cast<int64_t>(buffer.st_mtimespec.tv_sec) * 1000000000 +
						static_cast<int64_t>(buffer.st_mtimespec.tv_nsec);

				if (modificationTime > resultModificationTime) {
					resultModificationTime = modificationTime;
					result = entry->d_name;
				}
			}
		}
		closedir (dir);
	} else {
		throw std::runtime_error("Couldn't open current directory");
	}
	if (result.empty()) {
		throw std::runtime_error("No file found");
	}	return result;
}

int main() {
	ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);
	TaskC solver;
	std::ifstream in(getLastFileName("C-(small|large).*[.]in"));
	std::ofstream out("c.out");
	solver.solve(in, out);
	return 0;
}

