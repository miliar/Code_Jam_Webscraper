/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Majk
 */

#include <vector>
#include <iostream>
#include <unordered_map>
#include <map>
#include <iomanip>
#include <set>
#include <functional>
#include <fstream>
#include <algorithm>
#include <cassert>
#include <cmath>
#include <string>
#include <sstream>
#include <queue>
using namespace std;

#define x first
#define y second
constexpr int MOD = 1000000007;

typedef std::pair<int,int> pii;
typedef long long ll;
typedef unsigned int ui;

template<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}
template<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {for(size_t i=0;i<t.size();++i){o<<t[i]<<" \n"[i == t.size()-1];}return o;}
template<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;
template<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;

namespace std {
    template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}};
}
template<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}
template<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}
template<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }

template<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};
template<typename T>class vector3:public vector<vector<vector<T>>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector<vector<T>>>(a,vector<vector<T>>(b,vector<T>(c,t))){}};
// DINIC MAX-FLOW ALGORITHM
struct Dinic {int V,E;std::vector<int>l,t,c,n,a;std::vector<ll>p;Dinic(int v):V(v),E(0),l(V,-1),t(V),c(V){}
  void AddEdge(int x,int y,ll c1=1,ll c2=0){a.push_back(y);p.push_back(c1);n.push_back(l[x]);l[x]=E++;
  a.push_back(x);p.push_back(c2);n.push_back(l[y]);l[y]=E++;}ll push(int x,int v,ll flow){if(x==v)return
  flow;for(int&e=c[x];e!=-1;e=n[e]){int y=a[e];if(p[e]&&t[x]+1==t[y])if(ll f=push(y,v,min(flow,p[e])))
  return p[e]-=f,p[e^1]+=f,f;}return 0;}ll GetMaxFlow(int u,int v){ll ret=0;while(true){for(int i=0;i<V;
  i++){c[i]=l[i];t[i]=-1;}std::queue<int>Q;Q.push(u);t[u]=0;while(!Q.empty()){int x=Q.front();Q.pop();
  for (int e=l[x];e!=-1;e=n[e]){int y=a[e];if(p[e]&&t[y]==-1){Q.push(y);t[y]=t[x]+1;}}}if(t[v]==-1)break;
  while(ll f=push(u,v,1e18))ret+=f;}return ret;}std::vector<bool>GetMinCut(int u){std::queue<int>Q;Q.push(u);
  vector<bool>R(V,false);R[u]=true;while(!Q.empty()){int x=Q.front();Q.pop();for(int e=l[x];e!=-1;e=n[e])
  {int y=a[e];if(!R[y]&&p[e]>0){Q.push(y);R[y]=true;}}}return R;}};
// DINIC MAX-FLOW ALGORITHM

class TaskD {
public:
	void solve(istream& cin, ostream& cout) {
		int T; cin >> T;
		for (int t = 0; t < T; ++t) {
			int N, M; cin >> N >> M;
			vector2<bool> B(N,N,false), R(N,N,false);
			vector<bool> fC(N, true), fR(N, true), fA(2*N, true), fD(2*N, true);
			Dinic F(4*N+2);
			for (int i = 0; i < M; ++i) {
				char t; int r,c; cin >> t >> r >> c;
				--r; --c;
				if (t != 'x') {
					B[r][c] = true;
					fA[r+c] = false;
					fD[r+N-c] = false;
				}
				if (t != '+') {
					fC[c] = false;
					fR[r] = false;
					R[r][c] = true;
				}
			}

			vector2<bool> BO(B), RO(R);

			int r = 0, c = 0;
			while (r < N && c < N) {
				if (!fR[r]) ++r;
				else if (!fC[c]) ++c;
				else R[r++][c++] = true;
			}

			for (int r = 0; r < N; ++r) {
				for (int c = 0; c < N; ++c) {
					F.AddEdge(r+c, 3*N+r-c, 1);
				}
			}

			for (int i = 0; i < 2*N; ++i) {
				if (fA[i]) F.AddEdge(4*N, i, 1);
				if (fD[i]) F.AddEdge(2*N+i, 4*N+1, 1);
			}

			F.GetMaxFlow(4*N, 4*N+1);
			int edgeId = 0;
			for (int r = 0; r < N; ++r) {
				for (int c = 0; c < N; ++c) {
					if (F.p[edgeId] == 0) {
						B[r][c] = true;
					}
					edgeId += 2;
				}
			}

//			for (int r : {0,N-1}) {
//				for (int c = 0; c < N; ++c) {
//					if (fA[r+c] && fD[r+N-c]) {
//						B[r][c] = true;
//						fA[r + c] = fD[r + N - c] = false;
//					}
//				}
//			}
//

			cout << "Case #" << t+1 << ": ";
			int cnt = 0, score = 0;
			for (int r = 0; r < N; ++r) {
				for (int c = 0; c < N; ++c) {
					score += R[r][c] + B[r][c];
					cnt += R[r][c] != RO[r][c] || B[r][c] != BO[r][c];
				}
			}
			cout << score << ' ' << cnt << endl;
			for (int r = 0; r < N; ++r) {
				for (int c = 0; c < N; ++c) {
					if (R[r][c] != RO[r][c] || B[r][c] != BO[r][c]) {
						cout << (R[r][c] ? (B[r][c] ? 'o' : 'x') : '+') << ' ' << r+1 << ' ' << c+1 << endl;
					}
				}
			}
		}
	}
};
/*
x.....
+.x..+
+.o+.+
+..x.+
....x.
.....x
 */
#include <dirent.h>
#include <stdexcept>
#include <regex>
#include <sys/stat.h>
#include <cstdint>

std::string getLastFileName(const std::string& regexString) {
	DIR* dir;
	dirent* entry;
	std::string result = "";
	int64_t resultModificationTime = 0;
	std::regex regex(regexString);
	if ((dir = opendir (".")) != NULL) {
		while ((entry = readdir (dir)) != NULL) {
			if (std::regex_match(entry->d_name, regex)) {
				struct stat buffer;
				stat(entry->d_name, &buffer);
				int64_t modificationTime = static_cast<int64_t>(buffer.st_mtimespec.tv_sec) * 1000000000 +
						static_cast<int64_t>(buffer.st_mtimespec.tv_nsec);

				if (modificationTime > resultModificationTime) {
					resultModificationTime = modificationTime;
					result = entry->d_name;
				}
			}
		}
		closedir (dir);
	} else {
		throw std::runtime_error("Couldn't open current directory");
	}
	if (result.empty()) {
		throw std::runtime_error("No file found");
	}	return result;
}

int main() {
	ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);
	TaskD solver;
	std::ifstream in(getLastFileName("D-(small|large).*[.]in"));
	std::ofstream out("d.out");
	solver.solve(in, out);
	return 0;
}

