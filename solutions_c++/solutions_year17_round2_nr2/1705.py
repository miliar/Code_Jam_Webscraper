/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <algorithm>
#include <array>
#include <climits>
#include <cmath>
#include <cstdint>
#include <cstdlib>
#include <fstream>
#include <iostream>
#include <map>
#include <set>
#include <sstream>
#include <string>
#include <queue>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <vector>

#define check(e) \
  ((void) ((e) ? ((void)0) : __check(#e, __FILE__, __LINE__)))

void __check(const char* expr, const char* file, unsigned int line) {
//  while (true) {}
  printf("%s:%u: failed check `%s'\n", file, line, expr);
  abort();
}

#define forn(i, n) for (int i = 0; i < (int)(n); ++i)

using namespace std;

template<typename T, typename S>
std::ostream& operator<<(std::ostream& os, const std::pair<T, S>& p) {
  os << "(" << p.first << ", " << p.second << ")";
  return os;
}

template<typename T>
std::ostream& operator<<(std::ostream& os, const std::vector<T>& vector) {
  for (size_t i = 0; i < vector.size(); ++i) {
    os << (i > 0 ? " " : "") << vector[i];
  }
  return os;
}

template<typename T>
std::ostream& operator<<(std::ostream& os, const std::vector<std::vector<T>>& vector) {
  for (size_t i = 0; i < vector.size(); ++i) {
    os << vector[i] << std::endl;
  }
  return os;
}

struct Item {
  int count;
  char color;
};

ostream& operator<<(ostream& os, const Item& item) {
  os << "{" << item.count << ", " << item.color << "}";
  return os;
}

const char EMPTY = '.';

class TaskB {
public:
  void solve(std::istream& in, std::ostream& out) {
    int t;
    in >> t;
    forn(ti, t) {
      int n, r, o, y, g, b, v;
      in >> n >> r >> o >> y >> g >> b >> v;
      check(o == 0 && g == 0 && v == 0);
      vector<Item> a = {{r, 'R'},
                        {y, 'Y'},
                        {b, 'B'}};
//      out << ti + 1 << ": n = " << n << " a = " << a << endl;
      out << "Case #" << ti + 1 << ": " << solve_small(n, a) << endl;
    }
  }

  string solve_small(int n, vector<Item> a) {
    string res(n, EMPTY);
    int pos = 0;
    bool possible = true;
    char first_color = EMPTY;

    auto peek = [&](int type) {
      check(a[type].count > 0);
      res[pos] = a[type].color;
      a[type].count--;
    };

    while (pos < n) {
      sort(a.begin(), a.end(), [&](const Item& x, const Item& y) {
        if (x.count != y.count) {
          return x.count > y.count;
        }
        if (first_color != EMPTY) {
          if (x.color == first_color) {
            return true;
          } else if (y.color == first_color) {
            return false;
          }
        }
        return x.color > y.color;
      });

      if (a[0].count == 0) {
        possible = false;
        break;
      }
      if (pos == 0) {
        first_color = a[0].color;
        peek(0);
      } else if (pos + 1 < n) {
        if (a[0].color != res[pos - 1]) {
          peek(0);
        } else {
          if (a[1].count == 0) {
            possible = false;
            break;
          }
          if (a[1].count == a[2].count) {
            if (a[1].color == first_color) {
              peek(1);
            } else {
              peek(2);
            }
          } else {
            peek(1);
          }
        }
      } else {
        if (a[0].color == res[0] || a[0].color == res[pos - 1]) {
          possible = false;
          break;
        }
        peek(0);
      }
      ++pos;
    }
    if (possible) {
      check(res.find(EMPTY) == string::npos);
      for (int i = 1; i <= n; ++i) {
        check(res[i - 1] != res[i % n]);
      }
      return res;
    } else {
      return "IMPOSSIBLE";
    }
  }
};

int main() {
  ios_base::sync_with_stdio(false);
  TaskB solver;
  std::istream& in(std::cin);
  std::ostream& out(std::cout);
  solver.solve(in, out);
  return 0;
}
