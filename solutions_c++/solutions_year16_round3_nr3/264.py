#include <bits/stdc++.h>
using namespace std;

#ifdef ILIKEGENTOO
#   define Eo(x) { cerr << #x << " = " << (x) << endl; }
#   define E(x) { cerr << #x << " = " << (x) << "   "; }
#   define FREOPEN(x)
#else
#   define Eo(x) {}
#   define E(x) {}
#   define FREOPEN(x) (void)freopen(x ".in", "r", stdin);(void)freopen(x ".out", "w", stdout);
#endif
#define EO(x) Eo(x)
#define Sz(x) (int((x).size()))
#define All(x) (x).begin(),(x).end()

template<class A, class B> ostream &operator<<(ostream &os, const pair<A, B>& p) { return os << '(' << p.first << ", " << p.second << ')'; }

template<class C> void operator<<(vector<C> &v, const C &x){v.push_back(x);}
template<class D> void operator>>(vector<D> &v, D &x){assert(!v.empty()); x=v.back(); v.pop_back();}
template<class E> void operator<<(set<E> &v, const E &x){v.insert(x);}

typedef double flt;
typedef long long int64;
typedef unsigned long long uint64;
typedef pair<int, int> pii;
typedef unsigned char uchar;

const int inf = 0x3f3f3f3f;
const int64 inf64 = 0x3f3f3f3f3f3f3f3fLL;
const flt eps = 1e-8;
const flt pi = acos(-1.0);
const int dir[4][2] = { {0, 1}, {1, 0}, {0, -1}, {-1, 0} };

constexpr inline int64 bit(int t) { return 1LL << t; }

random_device rdev; mt19937 rmt(rdev()); uniform_int_distribution<> rnd(0, 0x7fffffff);
inline int mrand(int mod = 0x7fffffff) { return rnd(rmt) % mod; }

struct triple {
    int j, p, s;
};

const int maxn = 27;
int dp[bit(maxn)];

struct PairHash {
    size_t operator()(const pii& a) const {
        static std::hash<int> ha;
        return ha(a.first) ^ ha(a.second);
    }
};

vector<triple> solve(int j, int p, int s, int k) {
    const int all = j * p * s;
    assert(all <= maxn);
    Eo(all);

    /*
    auto toId = [=](int a, int b, int c) -> int {
        const int t = p * s;
        return a * t + b * s + c;
    };
    */
    auto fromId = [=](int q) -> triple {
        const int ss = q % s;
        q /= s;
        const int pp = q % p;
        const int jj = q / p;
        return {jj, pp, ss};
    };

    memset(dp, 0xc0, sizeof(dp));
    dp[0] = 0;

    for (int mask = 0; mask < bit(all); ++mask) if (dp[mask] >= 0) {

        int cntjp[12] = {0}, cntps[12] = {0}, cntjs[12] = {0};
        for (int i = 0; i < all; ++i) if (mask & bit(i)) {
            auto gs = fromId(i);
            cntjp[gs.j * 3 + gs.p]++;
            cntps[gs.p * 3 + gs.s]++;
            cntjs[gs.j * 3 + gs.s]++;
        }

        //for (int prev = 0; prev < all; ++prev) if (dp.count(pii(mask, prev))) {
            //E(mask); Eo(prev);
            for (int next = 0; next < all; ++next) {
                const int nmask = mask | bit(next);
                if (mask & bit(next)) continue;
                {
                    auto gs = fromId(next);
                    if (cntjp[gs.j * 3 + gs.p] >= k) continue;
                    if (cntjs[gs.j * 3 + gs.s] >= k) continue;
                    if (cntps[gs.p * 3 + gs.s] >= k) continue;
                }

                //dp[pii(nmask, next)] = pii(next, prev);
                dp[nmask] = next;
            }
        //}
    }

    vector<triple> res;
    int bestCnt = 0, bestI = 0;
    for (int i = 1; i < bit(all); ++i)
        if (dp[i] >= 0) {
            const int bcnt = __builtin_popcount(i);
            if (bcnt > bestCnt) {
                bestCnt = bcnt;
                bestI = i;
            }
        }
    assert(bestCnt);
    //E(bestCnt); E(bestI); Eo(bestJ);

    while (bestI) {
        const int bestJ = dp[bestI];
        res.push_back(fromId(bestJ));
        //E(bestI); Eo(bestJ);
        assert(bestI & bit(bestJ));
        const int nextI = bestI ^ bit(bestJ);
        bestI = nextI;
    }

    return res;
}

vector<triple> solveFast(int j, int p, int s, int k) {
    vector<triple> res;
    const int all = j * p * s;

    auto fromId = [=](int q) -> triple {
        const int ss = q % s;
        q /= s;
        const int pp = q % p;
        const int jj = q / p;
        return {jj, pp, ss};
    };

    vector<int> resid;
    for (int next = 0; next < all; ++next) {
        int cntjp[12] = {0}, cntps[12] = {0}, cntjs[12] = {0};
        for (int i : resid) {
            auto gs = fromId(i);
            cntjp[gs.j * 3 + gs.p]++;
            cntps[gs.p * 3 + gs.s]++;
            cntjs[gs.j * 3 + gs.s]++;
        }
        {
            auto gs = fromId(next);
            if (cntjp[gs.j * 3 + gs.p] >= k) continue;
            if (cntjs[gs.j * 3 + gs.s] >= k) continue;
            if (cntps[gs.p * 3 + gs.s] >= k) continue;
        }

        resid.push_back(next);
        res.push_back(fromId(next));
    }

    return res;
}


int main() {
    // FREOPEN("c");
    ios_base::sync_with_stdio(false); cin.tie(0);

#if 0
    int T; cin >> T;
    for (int test = 1; test <= T; ++test) {
        int j,p, s, k; cin >> j >>p >> s >> k;
        auto res = solveFast(j, p, s, k);

        cout << "Case #" << test << ": " << Sz(res) << endl;
        for (const auto& i : res)
            cout << i.j + 1 << ' ' << i.p + 1 << ' ' << i.s + 1 << '\n';
    }
#elif 0
    for (int k = 1; k <= 9; ++k)
        for (int s = 1; s <= 3; ++s)
            for (int p = 1; p <= s; ++p)
                for (int j = 1; j <= p; ++j) {
                    E(j); E(p); E(s); E(k);
                    auto res = solve(j, p, s, k);
                    cout << "ans[" << k << "][" << s << "][" << p << "][" << j << "]={" << endl;
                    for (const auto& i : res)
                        cout << "  " << i.j << ", " << i.p << ", " << i.s << ",\n";
                    cout << "}" << endl;
                    Eo(Sz(res));
                }
#else
    static vector<int> ans[10][4][4][4];
ans[1][1][1][1]={0,0,0,0};
ans[1][2][1][1]={0,0,0,0};
ans[1][2][2][1]={0,0,1,0,1,0,0};
ans[1][2][2][2]={0,0,0,0,1,1,1,0,1,1,1,0,0};
ans[1][3][1][1]={0,0,0,0};
ans[1][3][2][1]={0,0,1,0,1,0,0};
ans[1][3][2][2]={0,0,0,0,1,1,1,0,1,1,1,0,0};
ans[1][3][3][1]={0,0,2,0,1,1,0,2,0,0};
ans[1][3][3][2]={0,0,0,0,1,2,0,2,1,1,0,2,1,1,1,1,2,0,0};
ans[1][3][3][3]={0,0,1,0,1,0,0,2,2,1,0,0,1,1,2,1,2,1,2,0,2,2,1,1,2,2,0,0};
ans[2][1][1][1]={0,0,0,0};
ans[2][2][1][1]={0,0,0,0,0,1,0};
ans[2][2][2][1]={0,0,0,0,0,1,0,1,0,0,1,1,0};
ans[2][2][2][2]={0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,1,1,1,0};
ans[2][3][1][1]={0,0,0,0,0,1,0};
ans[2][3][2][1]={0,0,0,0,0,1,0,1,0,0,1,1,0};
ans[2][3][2][2]={0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,1,1,1,0};
ans[2][3][3][1]={0,0,1,0,0,2,0,1,0,0,1,2,0,2,0,0,2,1,0};
ans[2][3][3][2]={0,0,1,0,0,2,0,1,0,0,1,2,0,2,0,0,2,1,1,0,1,1,0,2,1,1,0,1,1,2,1,2,0,1,2,1,0};
ans[2][3][3][3]={0,0,0,0,0,2,0,1,0,0,1,1,0,2,1,0,2,2,1,0,0,1,0,1,1,1,1,1,1,2,1,2,0,1,2,2,2,0,1,2,0,2,2,1,0,2,1,2,2,2,0,2,2,1,0};
ans[3][1][1][1]={0,0,0,0};
ans[3][2][1][1]={0,0,0,0,0,1,0};
ans[3][2][2][1]={0,0,0,0,0,1,0,1,0,0,1,1,0};
ans[3][2][2][2]={0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,1,1,1,0};
ans[3][3][1][1]={0,0,0,0,0,1,0,0,2,0};
ans[3][3][2][1]={0,0,0,0,0,1,0,0,2,0,1,0,0,1,1,0,1,2,0};
ans[3][3][2][2]={0,0,0,0,0,1,0,0,2,0,1,0,0,1,1,0,1,2,1,0,0,1,0,1,1,0,2,1,1,0,1,1,1,1,1,2,0};
ans[3][3][3][1]={0,0,0,0,0,1,0,0,2,0,1,0,0,1,1,0,1,2,0,2,0,0,2,1,0,2,2,0};
ans[3][3][3][2]={0,0,0,0,0,1,0,0,2,0,1,0,0,1,1,0,1,2,0,2,0,0,2,1,0,2,2,1,0,0,1,0,1,1,0,2,1,1,0,1,1,1,1,1,2,1,2,0,1,2,1,1,2,2,0};
ans[3][3][3][3]={0,0,0,0,0,1,0,0,2,0,1,0,0,1,1,0,1,2,0,2,0,0,2,1,0,2,2,1,0,0,1,0,1,1,0,2,1,1,0,1,1,1,1,1,2,1,2,0,1,2,1,1,2,2,2,0,0,2,0,1,2,0,2,2,1,0,2,1,1,2,1,2,2,2,0,2,2,1,2,2,2,0};
ans[4][1][1][1]={0,0,0,0};
ans[4][2][1][1]={0,0,0,0,0,1,0};
ans[4][2][2][1]={0,0,0,0,0,1,0,1,0,0,1,1,0};
ans[4][2][2][2]={0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,1,1,1,0};
ans[4][3][1][1]={0,0,0,0,0,1,0,0,2,0};
ans[4][3][2][1]={0,0,0,0,0,1,0,0,2,0,1,0,0,1,1,0,1,2,0};
ans[4][3][2][2]={0,0,0,0,0,1,0,0,2,0,1,0,0,1,1,0,1,2,1,0,0,1,0,1,1,0,2,1,1,0,1,1,1,1,1,2,0};
ans[4][3][3][1]={0,0,0,0,0,1,0,0,2,0,1,0,0,1,1,0,1,2,0,2,0,0,2,1,0,2,2,0};
ans[4][3][3][2]={0,0,0,0,0,1,0,0,2,0,1,0,0,1,1,0,1,2,0,2,0,0,2,1,0,2,2,1,0,0,1,0,1,1,0,2,1,1,0,1,1,1,1,1,2,1,2,0,1,2,1,1,2,2,0};
ans[4][3][3][3]={0,0,0,0,0,1,0,0,2,0,1,0,0,1,1,0,1,2,0,2,0,0,2,1,0,2,2,1,0,0,1,0,1,1,0,2,1,1,0,1,1,1,1,1,2,1,2,0,1,2,1,1,2,2,2,0,0,2,0,1,2,0,2,2,1,0,2,1,1,2,1,2,2,2,0,2,2,1,2,2,2,0};
ans[5][1][1][1]={0,0,0,0};
ans[5][2][1][1]={0,0,0,0,0,1,0};
ans[5][2][2][1]={0,0,0,0,0,1,0,1,0,0,1,1,0};
ans[5][2][2][2]={0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,1,1,1,0};
ans[5][3][1][1]={0,0,0,0,0,1,0,0,2,0};
ans[5][3][2][1]={0,0,0,0,0,1,0,0,2,0,1,0,0,1,1,0,1,2,0};
ans[5][3][2][2]={0,0,0,0,0,1,0,0,2,0,1,0,0,1,1,0,1,2,1,0,0,1,0,1,1,0,2,1,1,0,1,1,1,1,1,2,0};
ans[5][3][3][1]={0,0,0,0,0,1,0,0,2,0,1,0,0,1,1,0,1,2,0,2,0,0,2,1,0,2,2,0};
ans[5][3][3][2]={0,0,0,0,0,1,0,0,2,0,1,0,0,1,1,0,1,2,0,2,0,0,2,1,0,2,2,1,0,0,1,0,1,1,0,2,1,1,0,1,1,1,1,1,2,1,2,0,1,2,1,1,2,2,0};
ans[5][3][3][3]={0,0,0,0,0,1,0,0,2,0,1,0,0,1,1,0,1,2,0,2,0,0,2,1,0,2,2,1,0,0,1,0,1,1,0,2,1,1,0,1,1,1,1,1,2,1,2,0,1,2,1,1,2,2,2,0,0,2,0,1,2,0,2,2,1,0,2,1,1,2,1,2,2,2,0,2,2,1,2,2,2,0};
ans[6][1][1][1]={0,0,0,0};
ans[6][2][1][1]={0,0,0,0,0,1,0};
ans[6][2][2][1]={0,0,0,0,0,1,0,1,0,0,1,1,0};
ans[6][2][2][2]={0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,1,1,1,0};
ans[6][3][1][1]={0,0,0,0,0,1,0,0,2,0};
ans[6][3][2][1]={0,0,0,0,0,1,0,0,2,0,1,0,0,1,1,0,1,2,0};
ans[6][3][2][2]={0,0,0,0,0,1,0,0,2,0,1,0,0,1,1,0,1,2,1,0,0,1,0,1,1,0,2,1,1,0,1,1,1,1,1,2,0};
ans[6][3][3][1]={0,0,0,0,0,1,0,0,2,0,1,0,0,1,1,0,1,2,0,2,0,0,2,1,0,2,2,0};
ans[6][3][3][2]={0,0,0,0,0,1,0,0,2,0,1,0,0,1,1,0,1,2,0,2,0,0,2,1,0,2,2,1,0,0,1,0,1,1,0,2,1,1,0,1,1,1,1,1,2,1,2,0,1,2,1,1,2,2,0};
ans[6][3][3][3]={0,0,0,0,0,1,0,0,2,0,1,0,0,1,1,0,1,2,0,2,0,0,2,1,0,2,2,1,0,0,1,0,1,1,0,2,1,1,0,1,1,1,1,1,2,1,2,0,1,2,1,1,2,2,2,0,0,2,0,1,2,0,2,2,1,0,2,1,1,2,1,2,2,2,0,2,2,1,2,2,2,0};
ans[7][1][1][1]={0,0,0,0};
ans[7][2][1][1]={0,0,0,0,0,1,0};
ans[7][2][2][1]={0,0,0,0,0,1,0,1,0,0,1,1,0};
ans[7][2][2][2]={0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,1,1,1,0};
ans[7][3][1][1]={0,0,0,0,0,1,0,0,2,0};
ans[7][3][2][1]={0,0,0,0,0,1,0,0,2,0,1,0,0,1,1,0,1,2,0};
ans[7][3][2][2]={0,0,0,0,0,1,0,0,2,0,1,0,0,1,1,0,1,2,1,0,0,1,0,1,1,0,2,1,1,0,1,1,1,1,1,2,0};
ans[7][3][3][1]={0,0,0,0,0,1,0,0,2,0,1,0,0,1,1,0,1,2,0,2,0,0,2,1,0,2,2,0};
ans[7][3][3][2]={0,0,0,0,0,1,0,0,2,0,1,0,0,1,1,0,1,2,0,2,0,0,2,1,0,2,2,1,0,0,1,0,1,1,0,2,1,1,0,1,1,1,1,1,2,1,2,0,1,2,1,1,2,2,0};
ans[7][3][3][3]={0,0,0,0,0,1,0,0,2,0,1,0,0,1,1,0,1,2,0,2,0,0,2,1,0,2,2,1,0,0,1,0,1,1,0,2,1,1,0,1,1,1,1,1,2,1,2,0,1,2,1,1,2,2,2,0,0,2,0,1,2,0,2,2,1,0,2,1,1,2,1,2,2,2,0,2,2,1,2,2,2,0};
ans[8][1][1][1]={0,0,0,0};
ans[8][2][1][1]={0,0,0,0,0,1,0};
ans[8][2][2][1]={0,0,0,0,0,1,0,1,0,0,1,1,0};
ans[8][2][2][2]={0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,1,1,1,0};
ans[8][3][1][1]={0,0,0,0,0,1,0,0,2,0};
ans[8][3][2][1]={0,0,0,0,0,1,0,0,2,0,1,0,0,1,1,0,1,2,0};
ans[8][3][2][2]={0,0,0,0,0,1,0,0,2,0,1,0,0,1,1,0,1,2,1,0,0,1,0,1,1,0,2,1,1,0,1,1,1,1,1,2,0};
ans[8][3][3][1]={0,0,0,0,0,1,0,0,2,0,1,0,0,1,1,0,1,2,0,2,0,0,2,1,0,2,2,0};
ans[8][3][3][2]={0,0,0,0,0,1,0,0,2,0,1,0,0,1,1,0,1,2,0,2,0,0,2,1,0,2,2,1,0,0,1,0,1,1,0,2,1,1,0,1,1,1,1,1,2,1,2,0,1,2,1,1,2,2,0};
ans[8][3][3][3]={0,0,0,0,0,1,0,0,2,0,1,0,0,1,1,0,1,2,0,2,0,0,2,1,0,2,2,1,0,0,1,0,1,1,0,2,1,1,0,1,1,1,1,1,2,1,2,0,1,2,1,1,2,2,2,0,0,2,0,1,2,0,2,2,1,0,2,1,1,2,1,2,2,2,0,2,2,1,2,2,2,0};
ans[9][1][1][1]={0,0,0,0};
ans[9][2][1][1]={0,0,0,0,0,1,0};
ans[9][2][2][1]={0,0,0,0,0,1,0,1,0,0,1,1,0};
ans[9][2][2][2]={0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,1,1,1,0};
ans[9][3][1][1]={0,0,0,0,0,1,0,0,2,0};
ans[9][3][2][1]={0,0,0,0,0,1,0,0,2,0,1,0,0,1,1,0,1,2,0};
ans[9][3][2][2]={0,0,0,0,0,1,0,0,2,0,1,0,0,1,1,0,1,2,1,0,0,1,0,1,1,0,2,1,1,0,1,1,1,1,1,2,0};
ans[9][3][3][1]={0,0,0,0,0,1,0,0,2,0,1,0,0,1,1,0,1,2,0,2,0,0,2,1,0,2,2,0};
ans[9][3][3][2]={0,0,0,0,0,1,0,0,2,0,1,0,0,1,1,0,1,2,0,2,0,0,2,1,0,2,2,1,0,0,1,0,1,1,0,2,1,1,0,1,1,1,1,1,2,1,2,0,1,2,1,1,2,2,0};
ans[9][3][3][3]={0,0,0,0,0,1,0,0,2,0,1,0,0,1,1,0,1,2,0,2,0,0,2,1,0,2,2,1,0,0,1,0,1,1,0,2,1,1,0,1,1,1,1,1,2,1,2,0,1,2,1,1,2,2,2,0,0,2,0,1,2,0,2,2,1,0,2,1,1,2,1,2,2,2,0,2,2,1,2,2,2,0};

    int T; cin >> T;
    for (int test = 1; test <= T; ++test) {
        int j,p, s, k; cin >> j >>p >> s >> k;
        k = min(9, k);
        vector<int> res = ans[k][s][p][j];
        res.pop_back();

        cout << "Case #" << test << ": " << Sz(res) / 3 << endl;
        for (int i = 0; i < Sz(res); ++i) {
            cout << res[i] + 1;
            if (i % 3 == 2)
                cout << '\n';
            else
                cout << ' ';
        }
    }
#endif

    return 0;
}
