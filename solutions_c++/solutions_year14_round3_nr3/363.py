#include <vector>#include <list>#include <map>#include <set>#include <deque>#include <stack>#include <bitset>#include <algorithm>#include <functional>#include <numeric>#include <utility>#include <sstream>#include <iostream>#include <iomanip>#include <cstdio>#include <cmath>#include <cstdlib>#include <ctime>using namespace std;typedef long long LL;typedef double D;#define PI 3.14159265358979323846264338327950288#define FI first#define SE second#define MP make_pair#define PB push_back#define F(I,A,B) for(int I=A;I<B;I++)#define FN(I,A,B) for(int I=A;I>B;I--)#define S(V) sort(V.begin(), V.end())#define CO(A) cout << A << endl#define MAX 52int p[1001][1001];vector < pair<int,int> > ptc;pair<int,int> np;int w,h,cx,cy;bool found ;long k,marked,stones = 0;int main(){    F(i,0,1001) F(j,0,1001) p[i][j] = 0;    int t, cc = 1;    cin >> t;    while (cc <=t) {        cout << "Case #" << cc << ": " ;        cc++;        cin >> w>>h>>k;        ptc.clear();        if(w>h) swap(w,h);        if(w<=2){            cout << k << endl;            continue;        }        F(i,0,w) F(j,0,h) p[i][j] = 0;        int angle = 0;        cx = w/2; cy = h/2;        p[cx][cy] = 1;        marked = 1;        stones = 1;        //cout << cx << "," << cy << endl;        while (marked<k) {            if (angle==4) {                if(cx!=0 && cx!=w-1 && cy!=0 && cy!=h-1)stones--;                found = false;                F(i,0,ptc.size()){                    np = ptc[i];                    cx = np.FI; cy = np.SE;                    if(cx!=0 && cx!=w-1 && cy!=0 && cy!=h-1){                        found = true;                        ptc.erase(ptc.begin() + i);                        break;                    }                }                if(!found){                    np = ptc[0];                    ptc.erase(ptc.begin());                    cx = np.FI; cy = np.SE;                }                angle = 0;                //cout << cx << "," << cy << endl;            }            switch (angle) {                case 0:                    if (cx<w-1 && p[cx+1][cy]==0) {                        ptc.PB(MP(cx+1, cy));                        p[cx+1][cy] = 1;                        stones++;                        marked++;                    }                    angle = 1;                    break;                case 1:                    if (cy<h-1 && p[cx][cy+1]==0) {                        ptc.PB(MP(cx, cy+1));                        p[cx][cy+1] = 1;                        stones++;                        marked++;                    }                    angle = 2;                    break;                case 2:                    if (cx>0 && p[cx-1][cy]==0) {                        ptc.PB(MP(cx-1, cy));                        p[cx-1][cy] = 1;                        stones++;                        marked++;                    }                    angle = 3;                    break;                case 3:                    if (cy>0 && p[cx][cy-1]==0) {                        ptc.PB(MP(cx, cy-1));                        p[cx][cy-1] = 1;                        stones++;                        marked++;                    }                    angle = 4;                    break;                default:                    break;            }        }        if(cx!=0 && cx!=w-1 && cy!=0 && cy!=h-1){            if(p[cx][cy-1]==1 && p[cx][cy+1]==1 && p[cx-1][cy]==1                && p[cx+1][cy]==1)            stones--;        }        cout << stones << endl;    }    return 0;}