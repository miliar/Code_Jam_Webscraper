#include <iterator>
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <cstdint>
#include <cassert>
#include <bitset>
#include <random>

// boost multiprecision and optional, available from http://www.boost.org/
// #include <boost/multiprecision/cpp_int.hpp>
#include <boost/optional.hpp>

// Checks if a number is prime using a sort-of prababilistic approach
boost::optional<uint64_t> is_prime_sieve(uint64_t num) {
    // Stores primes generated by the sieve for subsequent calls
    static std::vector<uint64_t> primes = { 2, 3 };
    static std::mt19937_64 gen;
    
    if (num < 2)
        return num;
    else if (num < 4)
        return boost::none;
    // check up to sqrt(num)
    uint64_t max = sqrt(num);
    std::uniform_int_distribution<uint64_t> dist(2, max);
    // check a random set of up to 100 numbers in the interval
    for (uint64_t i = 0; i < max; ++i) {
        uint64_t divisor = dist(gen);
        if (num % divisor == 0)
            return divisor;
    }
    
    return boost::none;
}

// Check if a jamcoin string is really a jamcoin. If it isn't, return boost::none. If it is, return a
// vector of the factors for each base 2 through 10.
boost::optional<std::vector<uint64_t>> validate_jamcoin(const std::string& coin) {
    //std::cout << "Validating jamcoin " << coin << std::endl;
    std::vector<uint64_t> factors;
    factors.reserve(9);
    for (int base = 2; base != 11; ++base) {
        uint64_t num = std::stoll(coin, 0, base);
        auto factor = is_prime_sieve(num);
        if (factor) {
            //std::cout << "factor " << *factor << " at base " << base << " for num " << num << std::endl;
            factors.push_back(*factor);
        } else {
            return boost::none;
        }
    }
    if (factors.size() == 9)
        return factors;
    else
        return boost::none;
}

// Generate a string which could potentially be a jamcoin, subject to primality of its 
// interpretation in various integer bases.
// The index ensures that jamcoins aren't repeated.
std::tuple<std::string, std::vector<uint64_t>> generate_jamcoin_string(uint32_t& index, uint32_t width) {
    while (index < UINT32_MAX) {
        //std::cout << "Generating jamcoin with index " << index << std::endl;
        std::bitset<32> bset(index);
        std::string bset_string = bset.to_string();
        ++index; // increment index so we don't re-check the same index again
        // generate a string with '1's at either end, e.g. 100101
        bset_string = "1" + bset_string.substr(32 - (width - 2)) + "1";
        
        // validate jamcoin
        auto factors = validate_jamcoin(bset_string);
        if (factors) {
            //std::cout << "FOUND valid jamcoin " << bset_string << std::endl;
            return std::make_tuple(bset_string, *factors);
        }
    }
    assert(false); // should never get here, means we couldn't find any valid jamcoins from the initial starting index
    std::vector<uint64_t> blank;
    return std::make_tuple("", blank);
}

int main() {
    // Read in the test cases
    uint32_t test_count = 0;
    std::cin >> test_count; // should always be 1
    assert(test_count == 1);
    uint32_t jam_length = 0, jam_count = 0;
    std::cin >> jam_length >> jam_count;
    
    std::mt19937_64 gen;
    
    
    std::cout << "Case #1:" << std::endl;
    uint32_t index = 0;
    for (uint32_t i = 1; i < (jam_count + 1); ++i) {
        //std::cout << "Generating jamcoin #" << i << std::endl;
        auto coin = generate_jamcoin_string(index, jam_length);
        std::cout << std::get<0>(coin);
        for (auto& divisor : std::get<1>(coin))
            std::cout << " " << divisor;
        std::cout << std::endl;
    }
    
    return 0;
}