#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef long long LL;
typedef pair<int,int> ii;
typedef vector<ii> vii;
typedef vector<int> vi;

#ifdef DEBUG
    #define cek(x) cout<<x
#else
    #define cek(x) if(false){}
#endif // DEBUG

#define fi first
#define se second
#define INF 1000000000
#define INFLL 1000000000000000000LL
#define EPS 1e-9
#define PI acos(-1.0)
#define pb push_back
#define TC() while(tc--)
#define FOR(i,n) for(int i=0;i<n;i++)
#define FORN(i,n) for(int i=0;i<=n;i++)
#define REP(i,a,b) for(int i=a;i<b;i++)
#define REPN(i,a,b) for(int i=a;i<=b;i++)
#define reset(a,b) memset(a,b,sizeof(a))
#define sc(x) scanf("%d",&x)

ll _sieve_size;
bitset<100000010> bs;   // 10^7 should be enough for most cases
vi primes;   // compact list of primes in form of vector<int>

void sieve(ll upperbound) {          // create list of primes in [0..upperbound]
  _sieve_size = upperbound + 1;                   // add 1 to include upperbound
  bs.set();                                                 // set all bits to 1
  bs[0] = bs[1] = 0;                                     // except index 0 and 1
  for (ll i = 2; i <= _sieve_size; i++) if (bs[i]) {
    // cross out multiples of i starting from i * i!
    for (ll j = i * i; j <= _sieve_size; j += i) bs[j] = 0;
    primes.push_back((int)i);  // also add this vector containing list of primes
} }                                           // call this method in main method


vi primeFactors(ll N) {   // remember: vi is vector of integers, ll is long long
  vi factors;                    // vi `primes' (generated by sieve) is optional
  ll PF_idx = 0, PF = primes[PF_idx];     // using PF = 2, 3, 4, ..., is also ok
  while (N != 1 && (PF * PF <= N)) {   // stop at sqrt(N), but N can get smaller
    while (N % PF == 0) { N /= PF; factors.push_back(PF); }    // remove this PF
    PF = primes[++PF_idx];                              // only consider primes!
  }
  if (N != 1) factors.push_back(N);     // special case if N is actually a prime
  return factors;         // if pf exceeds 32-bit integer, you have to change vi
}

int main(void){
    freopen("C:/Users/SONY/Desktop/C-small-attempt0.in", "r", stdin);
    freopen("C:/Users/SONY/Desktop/out2.txt","w",stdout);
    int tc;
    sieve(100000000);
    ll pangkat[12][19];
    REPN(i,2,10){
        FORN(j,16){
            ll num = 1;
            FOR(k,j)num*=i;
            pangkat[i][j] = num;
        }
    }

    sc(tc);
    while(tc--){
        int n,j;
        sc(n);sc(j);
        printf("Case #1:\n");
        int now = 0;
        //65535
        while(j){
            queue<int> st;
            int temp = now;
            while(temp){
                st.push(temp%2);
                temp/=2;
            }

            char xxx[20];
            xxx[0] = '1';
            xxx[n-1] = '1';
            xxx[n] = '\0';
            int idx = n-2;
            while(!st.empty()){
                int z = st.front();
                st.pop();
                xxx[idx] = z ? '1':'0';
                idx--;
            }
            REPN(zz,1,idx)xxx[zz] = '0';
            bool isvalid = true;
            vi angka2;
            REPN(q, 2, 10){
                ll angka = 0;
                FOR(klm, n){
                    angka += (xxx[klm] - '0') * pangkat[q][n-1-klm];
                }
                vi res = primeFactors(angka);
                if(res.size() <= 1){
                    isvalid = false;
                    break;
                }
                angka2.pb(res[0]);
            }
            if(isvalid){
                j--;
                cout<<xxx<<" ";
                FOR(zzzz, angka2.size())cout<<angka2[zzzz]<<" ";
                cout<<endl;
            }
            now++;
        }
    }



    return 0;
}



