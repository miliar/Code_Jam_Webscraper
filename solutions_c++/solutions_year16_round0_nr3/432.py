/********   All Required Header Files ********/
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <sstream>
#include <queue>
#include <deque>
#include <bitset>
#include <iterator>
#include <list>
#include <stack>
#include <map>
#include <set>
#include <functional>
#include <numeric>
#include <utility>
#include <limits>
#include <time.h>
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>

using namespace std;

typedef long long ll;
typedef vector<int> vi;
typedef map<int, int> mii;

ll _sieve_size;
bitset<10000010> bs;   // 10^7 should be enough for most cases
vi primes;   // compact list of primes in form of vector<int>

// first part

void sieve(ll upperbound) {          // create list of primes in [0..upperbound]
  _sieve_size = upperbound + 1;                   // add 1 to include upperbound
  bs.set();                                                 // set all bits to 1
  bs[0] = bs[1] = 0;                                     // except index 0 and 1
  for (ll i = 2; i <= _sieve_size; i++) if (bs[i]) {
    // cross out multiples of i starting from i * i!
    for (ll j = i * i; j <= _sieve_size; j += i) bs[j] = 0;
    primes.push_back((int)i);  // also add this vector containing list of primes
} }                                           // call this method in main method

bool isPrime(ll N) {                 // a good enough deterministic prime tester
  if (N <= _sieve_size) return bs[N];                   // O(1) for small primes
  for (int i = 0; i < (int)primes.size(); i++)
    if (N % primes[i] == 0) return false;
  return true;                    // it takes longer time if N is a large prime!
}                      // note: only work for N <= (last prime in vi "primes")^2


// second part

ll primeFactors(ll N) {   // remember: vi is vector of integers, ll is long long
  vi factors;                    // vi `primes' (generated by sieve) is optional
  ll PF_idx = 0, PF = primes[PF_idx];     // using PF = 2, 3, 4, ..., is also ok
  while (N != 1 && (PF * PF <= N)) {   // stop at sqrt(N), but N can get smaller
    if (N % PF == 0) { N /= PF; return PF; }
    PF = primes[++PF_idx];                              // only consider primes!
  }
  if (N != 1) return N;
}

ll base(ll n, int b) {
  ll long ans = 0;
  ll long b1 = 1;
  if (b == 2) return (long long) n;
  while (n != 0) {
    if (n % 2 == 1) ans += b1;
    b1 = b1 * b;
    n = n / 2;
  }
  return ans;
}

const int N = 32; 
int J = 500;

int main()
{
  int n = N / 2;
  assert(base(9, 2) == 9);
  assert(base(9, 3) == 28);
  assert(base(9, 4) == 65);
  assert(base(9, 5) == 126);
  assert(base(9, 6) == 217);
  assert(base(9, 7) == 344);
  assert(base(9, 8) == 513);
  assert(base(9, 9) == 730);
  assert(base(9, 10) == 1001);
  sieve(10000000);                       // can go up to 10^7 (need few seconds)
  cout << "Case #1:\n";
  ll max = 1LL << n;
  for(ll i = (1 << (n-1)) + 1; i<= max && J > 0 ; i += 2) {
    bool prime = false;
    for(int j = 2; j<=10;j++) {
      if (isPrime(base(i, j))) {
	prime = true;
	break;
      }
    }
    if(prime) continue;
    J --;
    ll z = (i << n) + i;
    //cout << std::bitset<N/2> (i) << endl;
    //cout << std::bitset<N> (z) << endl;

    if (!prime) {
      vi ans;
      cout << std::bitset<N> (z);
      for(int j = 2; j<=10;j++) {
	ll res = primeFactors(base(i, j));
	cout << " " << res;
      }
      cout << endl;
    }
  }
}
