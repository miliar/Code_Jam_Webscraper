/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <algorithm>
#include <array>
#include <climits>
#include <cmath>
#include <cstdint>
#include <cstdlib>
#include <fstream>
#include <iostream>
#include <map>
#include <set>
#include <sstream>
#include <string>
#include <queue>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <vector>

#define check(e) \
  ((void) ((e) ? ((void)0) : __check(#e, __FILE__, __LINE__)))

void __check(const char* expr, const char* file, unsigned int line) {
//  while (true) {}
  printf("%s:%u: failed check `%s'\n", file, line, expr);
  abort();
}

#define forn(i, n) for (int i = 0; i < (int)(n); ++i)
#define X first
#define Y second

typedef std::pair<int, int> pi;
using namespace std;

struct Segment {
  int from;
  int to;
};

bool operator>(const Segment& a, const Segment& b) {
  if (a.to - a.from != b.to - b.from) {
    return a.to - a.from > b.to - b.from;
  }
  return a.from > b.from;
}

class taskC {
public:
  void solve(std::istream& in, std::ostream& out) {
    int n_tests;
    in >> n_tests;
    forn(t, n_tests) {
      int n, k;
      in >> n >> k;
      auto res = solve(n, k);
      out << "Case #" << t + 1 << ": " << res.X << " " << res.Y << endl;
    }
  }

  pi solve(int n, int k) {
    set<Segment, greater<Segment>> s;
    s.insert({0, n - 1});
    forn(i, k - 1) {
      check(!s.empty());
      auto top = *s.begin();
      s.erase(s.begin());
//      cerr << "from: " << top.from << " to: " << top.to << endl;

      int middle = (top.to + top.from) / 2;
      if (middle - 1 >= top.from) {
        s.insert({top.from, middle - 1});
      }
      if (middle + 1 <= top.to) {
        s.insert({middle + 1, top.to});
      }
    }

    check(!s.empty());
    auto top = *s.begin();
    int middle = (top.to + top.from) / 2;
    int ls = middle - top.from;
    int rs = top.to - middle;;
    return {max(ls, rs), min(ls, rs)};
  }

};

int main() {
  ios_base::sync_with_stdio(false);
  taskC solver;
  std::istream& in(std::cin);
  std::ostream& out(std::cout);
  solver.solve(in, out);
  return 0;
}
