/*    CodeJam 2017    Round: 2    Task: B*//***********Template Starts Here***********/#include <bits/stdc++.h>#include <sys/resource.h>using namespace std;#include <ext/pb_ds/assoc_container.hpp>#include <ext/pb_ds/tree_policy.hpp>using namespace __gnu_pbds;#define pb push_back#define MP make_pair#define ff first#define ss second#define nl puts("")#define sp printf(" ")#define phl debug("Hello")#define FOR(i,x,y) for(vlong i = (x) ; i <= (y) ; ++i)#define ROF(i,x,y) for(vlong i = (y) ; i >= (x) ; --i)#define CLR(x,y) memset(x,y,sizeof(x))#define ALL(x) (x).begin(),(x).end()#define SZ(x) ((vlong)(x).size())#define UNIQUE(V) (V).erase(unique((V).begin(),(V).end()),(V).end())#define MIN(a,b) ((a)<(b)?(a):(b))#define MAX(a,b) ((a)>(b)?(a):(b))#define ABS(x) ((x)<0?-(x):(x))#define FABS(x) ((x)+eps<0?-(x):(x))#define SQ(x) ((x)*(x))#define LCM(x,y) (((x)/gcd((x),(y)))*(y))#define POPCOUNT __builtin_popcountll#define RIGHTMOST __builtin_ctzll#define LEFTMOST(x) (63-__builtin_clzll((x)))#define NUMDIGIT(x,y) (((vlong)(log10((x))/log10((y))))+1)#define NORM(x) if(x>=mod) x-=mod;if(x<0) x+=mod;#define ODD(x) (((x)&1)==0?(0):(1))#define Set(N,cur) N=(N|(1LL<<cur))#define Reset(N,cur) N=(N&(~(1LL<<cur)))#define Check(N,cur) (!((N&(1LL<<cur))==0))#define fast_cin ios_base::sync_with_stdio(false);cin.tie(NULL)typedef long long vlong;typedef unsigned long long uvlong;typedef pair < int, int > pii;typedef pair < vlong, vlong > pll;typedef vector<int> vi;typedef vector<vlong> vl;typedef vector<pll> vll;typedef tree <int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pb_ds;#ifdef forthright48     #include <ctime>     clock_t tStart = clock();     #define debug(args...) {dbg,args; cerr<<endl;}     #define timeStamp debug ("Execution Time: ", (double)(clock() - tStart)/CLOCKS_PER_SEC)     #define bug printf("%d\n",__LINE__);#else    #define debug(args...)  // Just strip off all debug tokens    #define timeStamp#endifstruct debugger{    template<typename T> debugger& operator , (const T& v){        cerr<<v<<" ";        return *this;    }}dbg;inline vlong gcd ( vlong a, vlong b ) {    a = ABS ( a ); b = ABS ( b );    while ( b ) { a = a % b; swap ( a, b ); } return a;}vlong ext_gcd ( vlong A, vlong B, vlong *X, vlong *Y ){    vlong x2, y2, x1, y1, x, y, r2, r1, q, r;    x2 = 1; y2 = 0;    x1 = 0; y1 = 1;    for (r2 = A, r1 = B; r1 != 0; r2 = r1, r1 = r, x2 = x1, y2 = y1, x1 = x, y1 = y ) {        q = r2 / r1;        r = r2 % r1;        x = x2 - (q * x1);        y = y2 - (q * y1);    }    *X = x2; *Y = y2;    return r2;}inline vlong modInv ( vlong a, vlong m ) {    vlong x, y;    ext_gcd( a, m, &x, &y );    x %= m;    if ( x < 0 ) x += m;    return x;}inline vlong bigmod ( vlong a, vlong p, vlong m ) {    vlong res = 1 % m, x = a % m;    while ( p ) {        if ( p & 1 ) res = ( res * x ) % m;        x = ( x * x ) % m; p >>= 1;    }    return res;}//int knightDir[8][2] = { {-2,1},{-1,2},{1,2},{2,1},{2,-1},{-1,-2},{1,-2},{-2,-1} };//int dir4[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};//int dir8[8][2] = {{-1,0},{0,1},{1,0},{0,-1},{-1,-1},{1,1},{1,-1},{-1,1}};const vlong inf = 2147383647;const vlong mod = 1000000007;const double pi = 2 * acos ( 0.0 );const double eps = 1e-11;/***********Template Ends Here***********///Kuhn's Algo for finding Maximum matching#define NODE 1003struct KUHN{    int left[NODE], right[NODE], vis[NODE], cc;    vi adj[NODE];    KUHN() : cc(1) {}    void clear( int n ) {        FOR(i,0,n) adj[i].clear();    }    bool tryK ( int v ) {        if ( vis[v] == cc ) return false;        vis[v] = cc;        for ( int i = 0; i < SZ(adj[v]); i++ ) {            int t = adj[v][i];            if ( right[t] == -1 ) {                right[t] = v; left[v] = t;                return true;            }        }        for ( int i = 0; i < SZ(adj[v]); i++ ) {            int t = adj[v][i];            if ( tryK ( right[t] ) ) {                right[t] = v; left[v] = t;                return true;            }        }        return false;    }        int match(int n) {        int res = 0;        bool done;        CLR(left,-1); CLR(right,-1);        do {            done = true; cc++;            FOR(i,0,n) {                if(left[i]==-1 && tryK(i)) {                    done = false;                }            }        } while(!done);        FOR(i,0,n) res += (left[i]!=-1);        return res;    }} grph;int t, tc;int n, m, c, uu, vv;int a[1005], b[1005];int cc1, cc2;int main () {    /*** Stack Memory Increase ***/    const rlim_t kStackSize = 256 * 1024 * 1024; // min stack size = 256 MB    struct rlimit rl;    int result;    result = getrlimit(RLIMIT_STACK, &rl);    if (result == 0) {        if (rl.rlim_cur < kStackSize) {            rl.rlim_cur = kStackSize;            result = setrlimit(RLIMIT_STACK, &rl);            if (result != 0) {                fprintf(stderr, "setrlimit returned result = %d\n", result);            }        }    }    /*** Stack Memory Increase ends ***/    #ifdef forthright48    //freopen ( "input.txt", "r", stdin );    freopen ( "B01.in", "r", stdin );    freopen ( "BoutputS.txt", "w", stdout );    #endif // forthright48    scanf("%d", &t);    tc = 0;    while (tc<t) {        tc++;        cerr << "---------------- Case: " << tc << " ----------------------\n";        printf("Case #%d:", tc);        //nl;        sp;		scanf("%d %d %d", &n, &c, &m);				grph.clear(m+2);		cc1 = cc2 = 0;		CLR(a,0);		CLR(b,0);				for (int i=0; i<m; i++) {			scanf("%d %d", &uu, &vv);			if (vv == 1) {				cc1++;				a[cc1] = uu;			}			else {				cc2++;				b[cc2] = uu;			}		}				for (int i=1; i<=cc1; i++) {			for (int j=1; j<=cc2; j++) {				if (a[i] == b[j]) continue;				else {					grph.adj[i].pb(j);				}			}		}				int res = grph.match(m+1);		//debug("===",res);				cc1 -= res; cc2 -= res;				int flag = 0;		for (int i=1; i<=m; i++) {			if (grph.left[i]!=-1) continue;			if (a[i] == 1) {				flag = 1;				break;			}		}		for (int i=1; i<=m; i++) {			if (grph.right[i]!=-1) continue;			if (b[i] == 1) {				flag = 1;				break;			}		}				int res2;				if (flag == 0) {			res += MAX(cc1,cc2);			res2 = MIN(cc1,cc2);		}				else {			res += cc1 + cc2;			res2 = 0;		}				printf("%d %d\n", res, res2);    }    return 0;}