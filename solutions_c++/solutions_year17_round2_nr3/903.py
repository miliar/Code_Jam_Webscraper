/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author chang
 */


#include <cstdio>
#include <iostream>
#include <cassert>
#include <cctype>
#include <cfloat>
#include <climits>
#include <cstring>
#include <bitset>
#include <deque>
#include <map>
#include <set>
#include <stack>
#include <queue>
#include <vector>
#include <algorithm>
#include <string>
#include <climits>
#include <cmath>
#include <fstream>
#include <iomanip>

using namespace std;

#define INF 1000000007

typedef long long ll;
typedef vector<int> vi;
typedef vector<double> vd;
typedef vector<ll> vll;
typedef vector<vector<int> > vvi;
typedef pair<int, int> ii;
typedef pair<long long, int> li;
typedef pair<double, int> di;
typedef vector<pair<int, int> > vii;
typedef vector<vector<pair<int, int> > > vvii;


#define TRACE

#ifdef TRACE
template<class T, class U>
ostream& operator<<(ostream& out, const pair<T, U>& a) {out << "[" << a.first << " " << a.second << "]"; return out;}
template<class T>
ostream& operator<<(ostream& out, const vector<T>& a) {out << "[ "; for (auto &it : a)out << it << " "; out << "]"; return out;}
template<class T>
ostream& operator<<(ostream& out, const set<T>& a) {out << "[ "; for (auto &it : a)out << it << " "; out << "]"; return out;}
template<class T>
ostream& operator<<(ostream& out, const multiset<T>& a) {out << "[ "; for (auto &it : a)out << it << " "; out << "]"; return out;}
template<class T, class U>
ostream& operator<<(ostream& out, const map<T, U>& a) {for (auto &it : a)out << it.first << " -> " << it.second << " | "; return out;}
template<class T, class U>
ostream& operator<<(ostream& out, const multimap<T, U>& a) {for (auto &it : a)out << it.first << " -> " << it.second << " | "; return out;}
#define pra(a,n) cerr<<#a<<" : ";for(int i=0;i<n;++i)cerr<<a[i]<<" ";cerr<<endl;
#define praa(a,n,m) cerr<<#a<<" : "<<endl;for(int i=0;i<n;++i){for(int j=0;j<m;++j)cerr<<a[i][j]<<" ";cerr<<endl;}
#define pr(...) __f(#__VA_ARGS__, __VA_ARGS__)
template <typename Arg1>
void __f(const char* name, Arg1&& arg1) {
    cerr << name << " : " << arg1 << std::endl;
}
template <typename Arg1, typename... Args>
void __f(const char* names, Arg1&& arg1, Args&&... args) {
    const char* comma = strchr(names + 1, ','); cerr.write(names, comma - names) << " : " << arg1 << " | "; __f(comma + 1, args...);
}
#else
#define pr(...)
#define pra(a,n)
#define praa(a,n,m)
#endif

#define all(x) (x).begin(), (x).end()
#define nall(x) (x).rbegin(), (x).rend()
#define sz(a) int((a).size())
#define boost ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)
#define pb push_back
#define rz resize
#define mp make_pair
#define F first
#define S second
#define FOR(i,a,b) for(int i=(a);i<=(b);++i)
#define NFOR(i,a,b) for(int i=(a);i>=(b);--i)
#define TCASE(in) int __T;in>>__T;FOR(Tc,1,__T)
#define ass(n,l,r) assert(n>=l and n<=r)
#define outprefix(tc) "Case #" << tc << ":"
inline int add(int a, int b, int m = INF) {a += b; if (a >= m)a -= m; return a;}
inline int mul(int a, int b, int m = INF) {return (int)(((ll)a * (ll)b) % m);}
inline int scan() {int x; scanf("%d",&x); return x;}

int dx[] {-1, 0, 1, 0, 1, 1, -1, -1};
int dy[] {0, -1, 0, 1, 1, -1, 1, -1};

const double PI  = 3.14159265358979323846L;
const int oo  = numeric_limits<int>::max() / 2 - 10;
const long long ool  = numeric_limits<long long>::max() / 2 - 10LL;
const double eps = 1e-6;
const long long mod = 1000000007;

const int ND = 102;

long long D[ND][ND], MD[ND][ND];
double limit[ND], speed[ND];
vector<li> od[ND];

bool visit[ND][ND];
double result[ND][ND];
void reset(){
	for(int i = 0; i < ND; ++i){
		od[i].clear();
		for(int j = 0; j < ND; ++j)
			visit[i][j] = false;
	}
}

void floyd(int n){
	for(int k = 0; k < n; ++k){
		for(int i = 0; i < n; ++i){
			for(int j = 0; j < n; ++j){
				if (MD[i][k] == -1 or  MD[k][j] == -1) continue;
				if (MD[i][j] == -1)
					MD[i][j] = MD[i][k]+MD[k][j];
				else 
					MD[i][j] = min(MD[i][j], MD[i][k]+MD[k][j]);

				// pr(i,j,k,MD[i][j],MD[i][k],MD[k][j]);
			}
		}
	}

	for(int i = 0; i < n; ++i){
		for(int j = 0; j < n; ++j){
			if (MD[i][j] == -1) continue;
			long long v1 = (MD[i][j] == -1) ? ool : MD[i][j];
			od[i].pb(mp(v1,j));
			// pr(i,j,v1);
		}
		sort(od[i].begin(),od[i].end());
	}
}

void compute(int x,int index){
	priority_queue<di,vector<di>,greater<di> > pq;
	result[index][x] = 0.0;
	pq.push(mp(0.0,x));

	while(!pq.empty()){
		double cur = pq.top().F;
		int y = pq.top().S;
		pq.pop();

		if (visit[index][y]) continue;
		visit[index][y] = true;
		result[index][y] = cur;

		// pr(cur,y);
		for(int i = 0; i < sz(od[y]); ++i){
			int z = od[y][i].S;
			double dist = (double)(od[y][i].F);

			if (visit[index][z]) continue;
			if (limit[y] < dist) continue;
			double add = (dist/speed[y]) + cur;
			pq.push(mp(add,z));
		}
	}
}

class Solver {
public:
	
	void solve(std::istream& in, std::ostream& out) {
		TCASE(in){
			reset();
			int n,q;
			in >> n >> q;

			for(int i = 0; i < n; ++i)
				in >> limit[i] >> speed[i];
			for(int i = 0; i < n; ++i){
				for(int j = 0; j < n; ++j){
					in >> D[i][j];
					MD[i][j] = D[i][j];
				}
			}

			floyd(n);
			for(int i = 0; i < n; ++i)
				compute(i,i);

			// pr(od[0]);
			// compute(0,0);
			out << outprefix(Tc) << " ";
			for(int i = 0; i < q; ++i){
				int x,y;
				in >> x >> y;

				x -= 1, y -= 1;
				out << setprecision(6) << fixed << result[x][y] << " ";
			}
			out << "\n";
		}
	}
};


int main() {
	Solver solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
