/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author RiaD
 */

#include <iostream>
#include <fstream>

#include <iostream>
#include <vector>
#include <cmath>

using namespace std;

class TaskB {
public:

	struct Her {
		double rate, t;
	};
	void solve(std::istream& in, std::ostream& out) {
		int n;
		double v, x;
		in >> n >> v >> x;

		vector<Her> big, small;
		bool ok = false;
		double resRate = 0;
		for (int i = 0; i < n; ++i) {
			Her her;
			in >> her.rate >> her.t;
			if(fabs(her.t - x) < 1e-6) {
				resRate += her.rate;
				ok = true;
			}
			else if(her.t < x) {
				small.push_back(her);
			}
			else {
				big.push_back(her);
			}
		}
		static int testNumber = 0;

		if((big.empty() || small.empty()) && !ok) {
			out << "Case #" << ++testNumber << ": " << "IMPOSSIBLE" << "\n";
			return;
		}

		while(!big.empty() && !small.empty()) {
			if(big.back().rate * big.back().t + small.back().rate * small.back().t < x * (big.back().rate + small.back().rate)) {
				//double needSmall = (x * (big.back().rate + small.back().rate) - big.back().rate * big.back().t) / small.back().t;
				double needSmall = big.back().rate * (big.back().t - x) / (x - small.back().t);
				resRate += needSmall + big.back().rate;
				big.pop_back();
				small.back().rate -= needSmall;
			}
			else {
				//double needBig = (x * (big.back().rate + small.back().rate) - small.back().rate * small.back().t) / big.back().t;
				double needBig = small.back().rate * (small.back().t - x) / (x - big.back().t);
				resRate += needBig + small.back().rate;
				small.pop_back();
				big.back().rate -= needBig;
			}
		}
		out << std::fixed;
		out.precision(20);
		out << "Case #" << ++testNumber << ": " << v / resRate << "\n";
	}
};


int main() {
	std::cin.sync_with_stdio(false);
	std::cin.tie(0);
	std::cout << std::fixed;
	std::cout.precision(20);
	TaskB solver;
	std::ifstream in("/Users/riad/Downloads/in.txt");
	std::ofstream out("/Users/riad/Downloads/b.out");
	int n;
in >> n;
for(int i = 0; i < n; ++i) {
	solver.solve(in, out);
}

	return 0;
}
