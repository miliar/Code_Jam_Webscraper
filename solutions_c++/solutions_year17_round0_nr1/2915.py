/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author chang
 */


#include <cstdio>
#include <iostream>
#include <cassert>
#include <cctype>
#include <cfloat>
#include <climits>
#include <cstring>
#include <bitset>
#include <deque>
#include <map>
#include <set>
#include <stack>
#include <queue>
#include <vector>
#include <algorithm>
#include <string>

#include <cmath>
#include <fstream>
#include <iomanip>

using namespace std;


#define TRACE

#ifdef TRACE
template<class T, class U>
ostream& operator<<(ostream& out, const pair<T, U>& a) {out << "[" << a.first << " " << a.second << "]"; return out;}
template<class T>
ostream& operator<<(ostream& out, const vector<T>& a) {out << "[ "; for (auto &it : a)out << it << " "; out << "]"; return out;}
template<class T>
ostream& operator<<(ostream& out, const set<T>& a) {out << "[ "; for (auto &it : a)out << it << " "; out << "]"; return out;}
template<class T>
ostream& operator<<(ostream& out, const multiset<T>& a) {out << "[ "; for (auto &it : a)out << it << " "; out << "]"; return out;}
template<class T, class U>
ostream& operator<<(ostream& out, const map<T, U>& a) {for (auto &it : a)out << it.first << " -> " << it.second << " | "; return out;}
template<class T, class U>
ostream& operator<<(ostream& out, const multimap<T, U>& a) {for (auto &it : a)out << it.first << " -> " << it.second << " | "; return out;}

#else
#define pr(...)
#define pra(a,n)
#define praa(a,n,m)
#endif

#define sz(a) int((a).size())
#define FOR(i,a,b) for(int i=(a);i<=(b);++i)
#define TCASE(in) int __T;in>>__T;FOR(Tc,1,__T)
#define outprefix(tc) "Case #" << tc << ": "

class Flipper {
public:
	void flip(string &s,int st,int en){
		for(int i = st; i <= en; ++i)
			s[i] = (s[i] == '+') ? '-' : '+';
	}

	bool valid(string &s,int st,int en){
		for(int i = st; i <= en; ++i)
			if (s[i] == '-') return false;
		return true;
	}

	void solve(std::istream& in, std::ostream& out) {
		TCASE(in){
			int n,k;
			string msg;
			in >> msg >> k;

			n = sz(msg);
			int last = n-k;
			int ans = 0;
			for(int i = 0; i <= last; ++i){
				if (msg[i] == '-') {
					++ans;
					flip(msg,i,i+k-1);
				}
			}

			if (!valid(msg,last,n-1))
				out << outprefix(Tc) << "IMPOSSIBLE\n";
			else
				out << outprefix(Tc) << ans << "\n";
		}
	}
};


int main() {
	Flipper solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
