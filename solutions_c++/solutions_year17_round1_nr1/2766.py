/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <algorithm>
#include <array>
#include <climits>
#include <cmath>
#include <cstdint>
#include <cstdlib>
#include <fstream>
#include <iostream>
#include <map>
#include <set>
#include <sstream>
#include <string>
#include <queue>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <vector>

#define forn(i, n) for (int i = 0; i < (int)(n); ++i)
#define mp make_pair
#define X first
#define Y second

typedef std::vector<int> vi;
typedef std::vector<vi> vvi;
typedef std::vector<char> vc;
typedef std::vector<vc> vvc;
typedef std::pair<int, int> pi;
using namespace std;

template<typename T, typename S>
std::ostream& operator<<(std::ostream& os, const std::pair<T, S>& p) {
  os << "(" << p.first << ", " << p.second << ")";
  return os;
}

template<typename T>
std::ostream& operator<<(std::ostream& os, const std::vector<T>& vector) {
  for (size_t i = 0; i < vector.size(); ++i) {
//    os << (i > 0 ? " " : "") << vector[i];
    os << vector[i];
  }
  return os;
}

template<typename T>
std::ostream& operator<<(std::ostream& os, const std::vector<std::vector<T>>& vector) {
  for (size_t i = 0; i < vector.size(); ++i) {
    os << vector[i] << std::endl;
  }
  return os;
}

class TaskA {
public:
  struct Rect {
    pi lt;
    pi rt;
  };

  void solve(std::istream& in, std::ostream& out) {
    int n_tests;
    in >> n_tests;
    forn(t, n_tests) {
      int r, c;
      in >> r >> c;
      vvc v(r, vc(c));
      forn(i, r) {
        forn(j, c) {
          in >> v[i][j];
        }
      }
      out << "Case #" << t + 1 << ":\n" << solve(r, c, v);
    }
  }

  vvc solve(int r, int c, vvc& v) {
    map<char, int> letter_to_count;
    forn(i, r) {
      forn(j, c) {
        char letter = v[i][j];
        if (letter != '?') {
          letter_to_count[letter]++;
        }
      }
    }
    set<char> processed;
    forn(i, r) {
      forn(j, c) {
        char letter = v[i][j];
        if (letter != '?') {
          if (processed.count(letter) > 0) {
            continue;
          }
          processed.insert(letter);

          auto letter_sum = build_sum(r, c, v, letter);
          auto question_sum = build_sum(r, c, v, '?');
          int max_square = 0;
          Rect max_rect;
          forn(li, r) {
            forn(lj, c) {
              for (int ri = li; ri < r; ++ri) {
                for (int rj = lj; rj < c; ++rj) {
                  int rect_sum =
                      get_value(letter_sum, ri, rj) -
                          get_value(letter_sum, li - 1, rj) -
                          get_value(letter_sum, ri, lj - 1) +
                          indicator(v, li - 1, lj - 1, letter);
                  int rect_quest_sum =
                      get_value(question_sum, ri, rj) -
                          get_value(question_sum, li - 1, rj) -
                          get_value(question_sum, ri, lj - 1) +
                          indicator(v, li - 1, lj - 1, '?');

                  int rect_square = (ri - li + 1) * (rj - lj + 1);
                  if (rect_sum == letter_to_count[letter] &&
                      rect_sum + rect_quest_sum == rect_square) {
                    if (rect_square > max_square) {
                      max_square = rect_square;
                      max_rect = {mp(li, lj), mp(ri, rj)};
                    }
                  }
                }
              }
            }
          }

          for (int ii = max_rect.lt.X; ii <= max_rect.rt.X; ++ii) {
            for (int jj = max_rect.lt.Y; jj <= max_rect.rt.Y; ++jj) {
              v[ii][jj] = letter;
            }
          }
        }
      }
    }

    forn(i, r) {
      forn(j, c) {
        if (v[i][j] == '?') {
          cerr << "cell " << i << " " << j << " is ?" << endl;
          cerr << v << endl;
          throw 1;
        }
      }
    }
    return v;
  }

  int get_value(const vvi& sum, int i, int j) {
    if (i < sum.size() && j < sum[i].size()) {
      return sum[i][j];
    } else {
      return 0;
    }
  }

  vvi build_sum(int r, int c, const vvc& v, char letter) {
    vvi sum(r, vi(c));
    forn(i, r) {
      forn(j, c) {
        sum[i][j] = indicator(v, i, j, letter) +
            (i > 0 ? sum[i - 1][j] : 0) +
            (j > 0 ? sum[i][j - 1] : 0) -
            (i > 0 && j > 0 ? sum[i - 1][j - 1] : 0);
      }
    }
    return sum;
  }

  int indicator(const vvc& v, int i, int j, char letter) {
    if (i < v.size() && j < v[i].size()) {
      return v[i][j] == letter ? 1 : 0;
    } else {
      return 0;
    }
  }
};

int main() {
  ios_base::sync_with_stdio(false);
  TaskA solver;
  std::istream& in(std::cin);
  std::ostream& out(std::cout);
  solver.solve(in, out);
  return 0;
}
