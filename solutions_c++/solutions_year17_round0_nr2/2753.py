// Generated by include.py
// Jakub Staro≈Ñ, 2016
// For more info see https://github.com/staronj/ProgrammingContestsLibrary




#include <iostream>
#include <iomanip>
#include <sstream>
#include <iterator>
#include <type_traits>
#include <algorithm>
#include <memory>
#include <utility>
#include <functional>
#include <bitset>
#include <vector>
#include <array>
#include <list>
#include <forward_list>
#include <deque>
#include <queue>
#include <set>
#include <map>
#include <unordered_set>
#include <unordered_map>
#include <cinttypes>
#include <ctime>
#include <cctype>
#include <cstring>
#include <random>
#include <cassert>

namespace pcl {

using byte    = unsigned char;
using int8    = std::int8_t;
using uint8   = std::uint8_t;
using int16   = std::int16_t;
using uint16  = std::uint16_t;
using int32   = std::int32_t;
using uint32  = std::uint32_t;
using int64   = std::int64_t;
using uint64  = std::uint64_t;


std::knuth_b Random(time(0));


uint32 Random32() {
  return Random();
}


uint64 Random64() {
  return uint64(Random32()) << 32 | uint64(Random32());
}


uint32 Random32(uint32 n) {
  return Random32() % n;
}


uint32 Random32(uint32 a, uint32 b) {
  assert(a < b);
  return (Random32() % (b - a)) + a;
}


uint64 Random64(uint64 n) {
  return Random64() % n;
}


uint64 Random64(uint64 a, uint64 b) {
  assert(a < b);
  return (Random64() % (b - a)) + a;
}


#ifdef __SIZEOF_INT128__
#define HAVE_INT128_TYPES
#endif

#define USE_INT128_TYPES_IF_AVAILABLE 0

#if defined(HAVE_INT128_TYPES) && USE_INT128_TYPES_IF_AVAILABLE
#define USE_INT128_TYPES
#endif

#ifdef USE_INT128_TYPES
using int128 = __int128;
using uint128 = unsigned __int128;
#endif

using bit_vector = std::vector<bool>;

using char_pair     = std::pair<char, char>;
using bool_pair     = std::pair<bool, bool>;
using int32_pair    = std::pair<int32, int32>;
using uint32_pair   = std::pair<uint32, uint32>;
using int64_pair    = std::pair<int64, int64>;
using uint64_pair   = std::pair<uint64, uint64>;

} 





namespace pcl {


template <typename T>
inline T operator++(T& obj, int) {
  T temp = obj;
  ++obj;
  return temp;
}


template <typename T>
inline T operator--(T& obj, int) {
  T temp = obj;
  --obj;
  return temp;
}


template <typename T, typename Integral>
inline typename std::enable_if<std::is_integral<Integral>::value, T&>::type
operator+=(T& obj, Integral n) {
  obj = obj + n;
  return obj;
}


template <typename T>
inline T& operator+=(T& obj1, const T& obj2) {
  obj1 = obj1 + obj2;
  return obj1;
}


template <typename T, typename Integral>
inline typename std::enable_if<std::is_integral<Integral>::value, T&>::type
operator-=(T& obj, Integral n) {
  obj = obj - n;
  return obj;
}


template <typename T>
inline T& operator-=(T& obj1, const T& obj2) {
  obj1 = obj1 - obj2;
  return obj1;
}


template <typename T, typename Integral>
inline typename std::enable_if<std::is_integral<Integral>::value, T&>::type
operator*=(T& obj, Integral n) {
  obj = obj * n;
  return obj;
}


template <typename T>
inline T& operator*=(T& obj1, const T& obj2) {
  obj1 = obj1 * obj2;
  return obj1;
}


template <typename T, typename Integral>
inline typename std::enable_if<std::is_integral<Integral>::value, T&>::type
operator%=(T& obj, Integral n) {
  obj = obj % n;
  return obj;
}


template <typename T>
inline T& operator%=(T& obj1, const T& obj2) {
  obj1 = obj1 % obj2;
  return obj1;
}


template <typename T, typename Integral>
inline typename std::enable_if<std::is_integral<Integral>::value, T>::type
operator+(Integral n, const T& obj) {
  return obj + n;
}


template <typename T, typename Integral>
inline typename std::enable_if<std::is_integral<Integral>::value, T>::type
operator*(Integral n, const T& obj) {
  return obj * n;
}


template <typename T, typename Integral>
inline typename std::enable_if<std::is_signed<Integral>::value, T>::type
operator-(const T& obj, Integral n) {
  return obj + (-n);
}


template <typename T, typename Integral>
inline typename std::enable_if<std::is_signed<Integral>::value, T&>::type
operator-=(const T& obj, Integral n) {
  return obj += (-n);
}


template <typename T>
inline bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}


template <typename T>
inline bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}


template <typename T>
inline bool operator>=(const T& lhs, const T& rhs) {
  return rhs <= lhs;
}


template <typename T1, typename T2>
inline bool operator!=(const T1& lhs, const T2& rhs) {
  return !(lhs == rhs);
}


template <typename Integral1, typename Integral2>
constexpr std::pair<Integral1, Integral2> operator+(const std::pair<Integral1, Integral2>& lhs, const std::pair<Integral1, Integral2>& rhs) {
  return std::pair<Integral1, Integral2>(lhs.first + rhs.first, lhs.second + rhs.second);
}


template <typename Integral1, typename Integral2>
constexpr std::pair<Integral1, Integral2> operator-(const std::pair<Integral1, Integral2>& lhs, const std::pair<Integral1, Integral2>& rhs) {
  return std::pair<Integral1, Integral2>(lhs.first - rhs.first, lhs.second - rhs.second);
}


template <typename Integral1, typename Integral2>
constexpr std::pair<Integral1, Integral2> operator%(const std::pair<Integral1, Integral2>& lhs, const std::pair<Integral1, Integral2>& rhs) {
  return std::pair<Integral1, Integral2>(lhs.first % rhs.first, lhs.second % rhs.second);
}


template <typename Integral1, typename Integral2>
constexpr std::pair<Integral1, Integral2> operator*(const std::pair<Integral1, Integral2>& lhs, const std::pair<Integral1, Integral2>& rhs) {
  return std::pair<Integral1, Integral2>(lhs.first * rhs.first, lhs.second * rhs.second);
}


template <typename Integral1, typename Integral2, typename Integral3>
constexpr std::pair<Integral1, Integral2> operator%(const std::pair<Integral1, Integral2>& lhs, const Integral3& rhs) {
  return std::pair<Integral1, Integral2>(lhs.first % rhs, lhs.second % rhs);
}


template <typename Integral1, typename Integral2, typename Integral3>
constexpr std::pair<Integral1, Integral2> operator*(const std::pair<Integral1, Integral2>& lhs, const Integral3& rhs) {
  return std::pair<Integral1, Integral2>(lhs.first * rhs, lhs.second * rhs);
}


} 


namespace pcl {

namespace detail {

template <bool B>
using enable_if = typename std::enable_if<B, bool>::type;

template <typename It>
using value_t = typename std::iterator_traits<It>::value_type;

template <typename It>
using difference_t = typename std::iterator_traits<It>::difference_type;

template <typename It>
using reference_t = typename std::iterator_traits<It>::reference;

template <typename It>
using pointer_t = typename std::iterator_traits<It>::pointer;

template <typename It>
using iterator_category_t = typename std::iterator_traits<It>::iterator_category;

} 


template<typename Iterator>
struct is_iterator {
private:
  template<typename I> static constexpr auto test(int)
  -> decltype(
      std::declval<detail::value_t<I>>(),
      std::declval<detail::difference_t<I>>(),
      std::declval<detail::reference_t<I>>(),
      std::declval<detail::pointer_t<I>>(),
      std::declval<detail::iterator_category_t<I>>(),
      *std::declval<I&>(),
      ++std::declval<I&>(),
      bool()) { return
      
      
      
        std::is_copy_constructible<I>::value &&
        std::is_copy_assignable<I>::value &&
        std::is_destructible<I>::value &&
        std::is_same<decltype(++std::declval<I&>()), I&>::value;
  }

  template<typename I> static constexpr bool test(...) { return false; }

public:
  static constexpr bool value = test<Iterator>(0);
  constexpr operator bool() const { return value; }
};

template<typename It>
constexpr bool is_iterator<It>::value;



template<typename Iterator>
struct is_input_iterator {
private:
  template<typename I> static constexpr auto test(int)
  -> decltype(
      detail::enable_if<is_iterator<I>::value>(),
      std::declval<I&>()++,
      *std::declval<I&>()++,
      std::declval<const I&>() == std::declval<const I&>(),
      std::declval<const I&>() != std::declval<const I&>(),
      bool()) { return
        std::is_convertible<decltype(std::declval<const I&>() == std::declval<const I&>()), bool>::value &&
        std::is_convertible<decltype(std::declval<const I&>() != std::declval<const I&>()), bool>::value &&
        std::is_same<decltype(*std::declval<I&>()), detail::reference_t<I>>::value &&
        std::is_convertible<detail::reference_t<I>, detail::value_t<I>>::value &&
        std::is_convertible<decltype(*std::declval<I&>()++), detail::value_t<I>>::value &&
        std::is_base_of<std::input_iterator_tag, detail::iterator_category_t<I>>::value;
  }

  template<typename I> static constexpr bool test(...) { return false; }

public:
  static constexpr bool value = test<Iterator>(0);
  constexpr operator bool() const { return value; }
};

template<typename It>
constexpr bool is_input_iterator<It>::value;


template<typename Iterator>
struct is_forward_iterator {
private:
  template<typename I> static constexpr auto test(int)
  -> decltype(
      detail::enable_if<is_input_iterator<I>::value>(),
      bool()) { return
        std::is_default_constructible<I>::value &&
        std::is_same<decltype(std::declval<I&>()++), I>::value &&
        std::is_same<decltype(*std::declval<I&>()++), detail::reference_t<I>>::value &&
        std::is_base_of<std::forward_iterator_tag, detail::iterator_category_t<I>>::value;
  }

  template<typename I> static constexpr bool test(...) { return false; }

public:
  static constexpr bool value = test<Iterator>(0);
  constexpr operator bool() const { return value; }
};

template<typename It>
constexpr bool is_forward_iterator<It>::value;


template<typename Iterator>
struct is_bidirectional_iterator {
private:
  template<typename I> static constexpr auto test(int)
  -> decltype(
      detail::enable_if<is_forward_iterator<I>::value>(),
      --std::declval<I&>(),
      std::declval<I&>()--,
      *std::declval<I&>()--,
      bool()) { return
        std::is_same<decltype(--std::declval<I&>()), I&>::value &&
        std::is_convertible<decltype(std::declval<I&>()--), const I&>::value &&
        std::is_same<decltype(*std::declval<I&>()--), detail::reference_t<I>>::value &&
        std::is_base_of<std::bidirectional_iterator_tag, detail::iterator_category_t<I>>::value;
  }

  template<typename I> static constexpr bool test(...) { return false; }

public:
  static constexpr bool value = test<Iterator>(0);
  constexpr operator bool() const { return value; }
};

template<typename It>
constexpr bool is_bidirectional_iterator<It>::value;


template<typename Iterator>
struct is_random_access_iterator {
private:
  template<typename I> static constexpr auto test(int)
  -> decltype(
      detail::enable_if<is_bidirectional_iterator<I>::value>(),
      std::declval<I&>() += std::declval<detail::difference_t<I>>(),
      std::declval<I&>() + std::declval<detail::difference_t<I>>(),
      std::declval<detail::difference_t<I>>() + std::declval<I&>(),
      std::declval<I&>() -= std::declval<detail::difference_t<I>>(),
      std::declval<I&>() - std::declval<detail::difference_t<I>>(),
      std::declval<I&>() - std::declval<I&>(),
      std::declval<I&>()[std::declval<detail::difference_t<I>>()],
      std::declval<I&>() < std::declval<I&>(),
      std::declval<I&>() <= std::declval<I&>(),
      std::declval<I&>() > std::declval<I&>(),
      std::declval<I&>() >= std::declval<I&>(),
      bool()) { return
        std::is_same<decltype(std::declval<I&>() += std::declval<detail::difference_t<I>>()), I&>::value &&
        std::is_same<decltype(std::declval<I&>() + std::declval<detail::difference_t<I>>()), I>::value &&
        std::is_same<decltype(std::declval<detail::difference_t<I>>() + std::declval<I&>()), I>::value &&
        std::is_same<decltype(std::declval<I&>() -= std::declval<detail::difference_t<I>>()), I&>::value &&
        std::is_same<decltype(std::declval<I&>() - std::declval<detail::difference_t<I>>()), I>::value &&
        std::is_same<decltype(std::declval<I&>() - std::declval<I&>()), detail::difference_t<I>>::value &&
        std::is_convertible<decltype(std::declval<I&>()[std::declval<detail::difference_t<I>>()]), detail::reference_t<I>>::value &&
        std::is_convertible<decltype(std::declval<I&>() < std::declval<I&>()), bool>::value &&
        std::is_convertible<decltype(std::declval<I&>() <= std::declval<I&>()), bool>::value &&
        std::is_convertible<decltype(std::declval<I&>() > std::declval<I&>()), bool>::value &&
        std::is_convertible<decltype(std::declval<I&>() >= std::declval<I&>()), bool>::value &&
        std::is_same<std::random_access_iterator_tag, detail::iterator_category_t<I>>::value;
  }

  template<typename I> static constexpr bool test(...) { return false; }

public:
  static constexpr bool value = test<Iterator>(0);
  constexpr operator bool() const { return value; }
};

template<typename It>
constexpr bool is_random_access_iterator<It>::value;

} 



namespace pcl {


template <typename Helper>
class random_access_iterator {
public:
  using value_type = typename Helper::value_type;
  using reference = typename Helper::reference;
  using pointer = typename Helper::pointer;
  using difference_type = typename Helper::difference_type;
  using iterator_category = std::random_access_iterator_tag;
  using self_type = random_access_iterator;

  random_access_iterator() = default;
  random_access_iterator(const random_access_iterator&) = default;
  random_access_iterator(random_access_iterator&) = default;
  random_access_iterator(random_access_iterator&&) = default;
  random_access_iterator& operator=(random_access_iterator&&) = default;
  random_access_iterator& operator=(const random_access_iterator&) = default;

  template <typename... Args>
  explicit random_access_iterator(Args&&... args):
      helper_(std::forward<Args>(args)...) { }

  reference operator*() const { return helper_.value(); }
  pointer operator->() const { return helper_.ptr(); }

  self_type& operator++() {
    helper_.next();
    return *this;
  }

  self_type operator++(int) {
    auto it = *this;
    this->operator++();
    return it;
  }

  self_type& operator--() {
    helper_.prev();
    return *this;
  }

  self_type operator--(int) {
    auto it = *this;
    this->operator--();
    return it;
  }

  self_type& operator+=(difference_type n) {
    helper_.advance(n);
    return *this;
  }

  self_type& operator-=(difference_type n) {
    helper_.advance(-n);
    return *this;
  }

  friend self_type operator+(self_type lhs, difference_type rhs) {
    lhs.helper_.advance(rhs);
    return lhs;
  }

  friend self_type operator+(difference_type lhs, self_type rhs) {
    rhs.helper_.advance(lhs);
    return rhs;
  }

  friend self_type operator-(self_type lhs, difference_type rhs) {
    lhs.helper_.advance(-rhs);
    return lhs;
  }

  reference operator[](difference_type n) const {
    return *(*this + n);
  }

  friend difference_type operator-(const self_type& lhs, const self_type& rhs) {
    return lhs.helper_.difference(rhs.helper_);
  }

  friend bool operator==(const self_type& lhs, const self_type& rhs) {
    return lhs.helper_.equal(rhs.helper_);
  }

  friend bool operator!=(const self_type& lhs, const self_type& rhs) {
    return !(lhs == rhs);
  }

  friend bool operator<(const self_type& lhs, const self_type& rhs) {
    return lhs.helper_.less(rhs.helper_);
  }
  
  friend bool operator>(const self_type& lhs, const self_type& rhs) {
    return rhs < lhs;
  }

  friend bool operator<=(const self_type& lhs, const self_type& rhs) {
    return !(rhs < lhs);
  }
  
  friend bool operator>=(const self_type& lhs, const self_type& rhs) {
    return rhs <= lhs;
  }

  const Helper& getHelper() const {
    return helper_;
  }

  Helper& getHelper() {
    return helper_;
  }
  
private:
  Helper helper_;
};

} 

namespace pcl {

namespace detail {
namespace is_iterable_impl {

using std::begin;
using std::end;

template <typename C>
using begin_t = decltype(begin(std::declval<C&>()));

template <typename C>
using end_t = decltype(end(std::declval<C&>()));

template<typename I> static constexpr auto test(int)
-> decltype(
std::declval<begin_t<I>>(),
    std::declval<end_t<I>>(),
    bool()) { return
      std::is_same<begin_t<I>, end_t<I>>::value &&
      is_iterator<begin_t<I>>::value;
}

template<typename I> static constexpr bool test(...) { return false; }

} 
} 


template<typename T>
using is_iterable = std::integral_constant<bool, detail::is_iterable_impl::test<T>(0)>;

namespace detail {

template <typename Integral>
struct counting_iterator_helper {
  static_assert(std::is_integral<Integral>::value, "counting_iterator's template argument should be integral");
  using value_type = Integral;
  using reference = value_type;
  using pointer = const value_type*;
  using difference_type = typename std::make_signed<Integral>::type;
  using self_type = counting_iterator_helper;

  counting_iterator_helper(): value_() { }
  explicit counting_iterator_helper(Integral n): value_(n) { }

  void next() { ++value_; }
  void prev() { --value_; }
  reference value() const { return value_; }
  pointer ptr() const { return &value_; }

  bool equal(const self_type& other) const
    { return value_ == other.value_; }

  void advance(difference_type diff)
    { value_ += diff; }

  difference_type difference(const self_type& other) const
    { return value_ - other.value_; }

  bool less(const self_type& other) const
    { return value_ < other.value_; }

private:
  Integral value_;
};

template <typename Integral>
struct reverse_counting_iterator_helper {
  static_assert(std::is_integral<Integral>::value, "reverse_counting_iterator's template argument should be integral");
  using value_type = Integral;
  using reference = value_type;
  using pointer = const value_type*;
  using difference_type = typename std::make_signed<Integral>::type;
  using self_type = reverse_counting_iterator_helper;

  reverse_counting_iterator_helper(): value_() { }
  reverse_counting_iterator_helper(Integral n): value_(n) { }

  void next() { --value_; }
  void prev() { ++value_; }
  reference value() const { return value_; }
  pointer ptr() const { return &value_; }

  bool equal(const self_type& other) const
  { return value_ == other.value_; }

  void advance(difference_type diff)
  { value_ -= diff; }

  difference_type difference(const self_type& other) const
  { return other.value_ - value_; }

  bool less(const self_type& other) const
  { return value_ > other.value_; }

private:
  Integral value_;
};

} 


template <typename Integral>
using counting_iterator = random_access_iterator<detail::counting_iterator_helper<Integral>>;


template <typename Integral>
auto make_counting_iterator(Integral n) -> counting_iterator<Integral> {
  return counting_iterator<Integral>(n);
}


template <typename T>
std::ostream& operator<<(std::ostream& stream, counting_iterator<T> it) {
  return stream << *it;
}


template <typename Integral>
using reverse_counting_iterator = random_access_iterator<detail::reverse_counting_iterator_helper<Integral>>;



template <typename Integral>
auto make_reverse_counting_iterator(Integral n) -> reverse_counting_iterator<Integral> {
  return reverse_counting_iterator<Integral>(n);
}


template <typename Iterator>
class iterator_range {
public:
  static_assert(is_iterator<Iterator>::value, "iterator_range's template argument should be iterator!");

  using iterator_type = Iterator;
  using size_type = typename std::iterator_traits<Iterator>::difference_type;

  iterator_range() = default;

  explicit iterator_range(Iterator begin, Iterator end):
      begin_(std::move(begin)), end_(std::move(end)) { }

  iterator_type begin() const {
    return begin_;
  }

  iterator_type end() const {
    return end_;
  }

  bool empty() const {
    return begin_ == end_;
  }

  size_type size() const {
    return std::distance(begin_, end_);
  }

private:
  iterator_type begin_;
  iterator_type end_;
};


template <typename Iterator>
auto make_range(Iterator begin, Iterator end) -> iterator_range<Iterator> {
  return iterator_range<Iterator>(std::move(begin), std::move(end));
}


template <typename Integral>
auto range(Integral begin, Integral end) ->
typename std::enable_if<std::is_integral<Integral>::value, iterator_range<counting_iterator<Integral>>>::type {
  return make_range(make_counting_iterator(begin), make_counting_iterator(end));
}


template <typename Integral>
auto rrange(Integral begin, Integral end) ->
typename std::enable_if<std::is_integral<Integral>::value, iterator_range<reverse_counting_iterator<Integral>>>::type {
  return make_range(make_reverse_counting_iterator(end - 1), make_reverse_counting_iterator(begin - 1));
}


template <typename Iterator, typename Mapper>
class mapping_iterator {
public:
  using self_type = mapping_iterator;
  using underlying_value_type = decltype(*std::declval<Iterator>());
  using value_type = decltype(std::declval<Mapper>()(std::declval<underlying_value_type>()));
  using reference = value_type;
  using pointer = typename std::remove_reference<value_type>::type*;
  using difference_type = typename std::iterator_traits<Iterator>::difference_type;
  using iterator_category = typename std::iterator_traits<Iterator>::iterator_category;

  mapping_iterator(const Mapper& mapper = Mapper()):
      iterator_(), mapper_(mapper) { }

  explicit mapping_iterator(Iterator iterator, const Mapper& mapper = Mapper()):
      iterator_(iterator), mapper_(mapper) { }

  reference operator*() const {
    return mapper_(*iterator_);
  }

  self_type& operator++() {
    ++iterator_;
    return *this;
  }

  self_type& operator--() {
    --iterator_;
    return *this;
  }

  self_type& operator+=(difference_type n) {
    iterator_ += n;
    return *this;
  }

  friend self_type operator+(const self_type& obj, difference_type n) {
    return self_type(obj.iterator_ + n, obj.mapper_);
  }

  friend difference_type operator-(const self_type& lhs, const self_type& rhs) {
    return lhs.iterator_ - rhs.iterator_;
  }

  value_type operator[](difference_type n) {
    return *(*this + n);
  }

  friend bool operator<(const self_type& lhs, const self_type& rhs) {
    return lhs.iterator_ < rhs.iterator_;
  }

  friend bool operator==(const self_type& lhs, const self_type& rhs) {
    return lhs.iterator_ == rhs.iterator_;
  }

private:
  Iterator iterator_;
  Mapper mapper_;
};

namespace detail {

template <typename ValuesIterator>
struct IndirectMapper {
  static_assert(is_iterator<ValuesIterator>::value, "first indirect_iterator's template argument must be iterator.");
  static_assert(
      std::is_same<typename std::iterator_traits<ValuesIterator>::iterator_category, std::random_access_iterator_tag>::value,
      "ValuesIterator must be random assess iterator."
  );

  using value_type = typename std::iterator_traits<ValuesIterator>::value_type;
  using reference = const value_type&;
  using index_type = typename std::iterator_traits<ValuesIterator>::difference_type;

  IndirectMapper() = default;

  IndirectMapper(ValuesIterator values):
      values_(values) { }

  reference operator()(index_type n) const {
    return *(values_ + n);
  }

private:
  ValuesIterator values_;
};

} 

template <typename ValuesIterator, typename IndexesIterator>
using indirect_iterator = mapping_iterator<IndexesIterator, detail::IndirectMapper<ValuesIterator>>;


template <typename ValuesIterator, typename IndexesIterator>
auto make_indirect_iterator(ValuesIterator values, IndexesIterator indexes) ->
indirect_iterator<ValuesIterator, IndexesIterator> {
  detail::IndirectMapper<ValuesIterator> mapper(values);
  return indirect_iterator<ValuesIterator, IndexesIterator>(std::move(indexes), std::move(mapper));
};

} 







namespace pcl {


template <typename Helper>
class input_iterator {
public:
  using value_type = typename Helper::value_type;
  using reference = typename Helper::reference;
  using pointer = typename Helper::pointer;
  using difference_type = typename Helper::difference_type;
  using iterator_category = std::input_iterator_tag;
  using self_type = input_iterator;

  input_iterator() = default;

  template <typename... Args>
  explicit input_iterator(Args&&... args):
      helper_(std::forward<Args>(args)...) { }

  reference operator*() const { return helper_.value(); }
  pointer operator->() const { return helper_.ptr(); }

  self_type& operator++() {
    helper_.next();
    return *this;
  }

  self_type operator++(int) {
    auto it = *this;
    this->operator++();
    return it;
  }

  friend bool operator==(const self_type& lhs, const self_type& rhs) {
    return lhs.helper_.equal(rhs.helper_);
  }

  friend bool operator!=(const self_type& lhs, const self_type& rhs) {
    return !(lhs == rhs);
  }

  const Helper& getHelper() const {
    return helper_;
  }

  Helper& getHelper() {
    return helper_;
  }

private:
  Helper helper_;
};

} 



namespace pcl {

struct Nothing_t {
  constexpr Nothing_t() { };
};


constexpr Nothing_t Nothing;


template <typename T>
struct Maybe {
public:
  using value_type = T;
  using pointer = value_type*;
  using const_pointer = const value_type*;
  using reference = value_type&;
  using const_reference = const value_type&;
  using self_type = Maybe;

  
  Maybe() = default;

  
  Maybe(Nothing_t): Maybe() { }

  
  Maybe(value_type value) {
    construct(std::move(value));
  }

  
  Maybe(const Maybe& other) {
    *this = other;
  }

  
  Maybe(Maybe&& other) {
    *this = std::move(other);
  }

  
  Maybe& operator=(value_type value) {
    destroy();
    construct(std::move(value));
    return *this;
  }

  
  Maybe& operator=(const Maybe& other) {
    destroy();
    if (!other.empty())
      construct(other.get());
    return *this;
  }

  
  Maybe& operator=(Maybe&& other) {
    destroy();
    if (!other.empty()) {
      construct(std::move(other.get()));
      other.destroy();
    }
    return *this;
  }

  
  bool empty() const {
    return !initialized_;
  }

  
  reference get() {
    if (empty())
        throw std::logic_error("Empty maybe!");
    
    return storage_.ref();
  }  

  
  const_reference get() const {
    if (empty())
        throw std::logic_error("Empty maybe!");
    
    return storage_.ref();
  }  

  friend bool operator==(const self_type& lhs, Nothing_t) {
      return lhs.empty();
  }

  friend bool operator==(Nothing_t, const self_type& rhs) {
      return rhs.empty();
  }

  friend bool operator==(const self_type& lhs, const self_type& rhs) {
    if (lhs.empty() || rhs.empty())
      return lhs.empty() && rhs.empty();
    else
      return lhs.get() == rhs.get();
  }
  
  ~Maybe() {
    destroy();
  }

private:
  void construct(value_type value) {
    storage_.construct(std::move(value));
    initialized_ = true;
  }

  void destroy() {
    if (initialized_)
      storage_.destroy();
    initialized_ = false;
  }

  struct storage_type {
    void construct(value_type value) {
        new (data_) value_type(std::move(value));
    }

    void destroy() {
        ref().~value_type();   
    }

    pointer ptr() {
        return reinterpret_cast<pointer>(data_);
    }

    const_pointer ptr() const {
        return reinterpret_cast<const_pointer>(data_);
    }

    reference ref() {
        return *ptr();
    }

    const_reference ref() const {
        return *ptr();
    }
 
  private:
    byte data_[sizeof(value_type)];
  };

  storage_type storage_;
  bool initialized_ = false;
};


template <typename T>
Maybe<T> Just(T value) {
  return Maybe<T>(std::move(value));
}


} 

namespace pcl {


template <typename ValueType>
class GeneratorBase {
public:
  using value_type = ValueType;
  using pointer = std::unique_ptr<GeneratorBase>;

  GeneratorBase() = default;
  GeneratorBase(const GeneratorBase&) = delete;
  GeneratorBase& operator=(const GeneratorBase&) = delete;
  GeneratorBase(GeneratorBase&&) = default;
  virtual ~GeneratorBase() = default;

  
  virtual Maybe<value_type> next() = 0;
};

template <class ValueType>
using Generator = std::unique_ptr<GeneratorBase<ValueType>>;


template <typename Generator>
struct is_generator : std::false_type { };

template <typename GeneratorType>
struct is_generator<std::unique_ptr<GeneratorType>> :
    std::is_base_of<GeneratorBase<typename GeneratorType::value_type>, GeneratorType> { };

template <typename GeneratorType>
struct is_generator<std::unique_ptr<GeneratorType>&> :
    std::is_base_of<GeneratorBase<typename GeneratorType::value_type>, GeneratorType> { };

namespace detail {

template <typename GeneratorType, typename... Args>
Generator<typename GeneratorType::value_type> build_generator(Args&& ... args) {
  return Generator<typename GeneratorType::value_type>(new GeneratorType(std::forward<Args>(args)...));
};

} 


template <typename Callable>
auto generate(Callable&& callable) ->
Generator<typename decltype(callable())::value_type>
{
  using value_type = typename decltype(callable())::value_type;

  class FromCallableGenerator: public GeneratorBase<value_type> {
  public:
    FromCallableGenerator(Callable&& callable):
        callable_(std::move(callable)) { }

    Maybe<value_type> next() final {
      return callable_();
    }

  private:
    Callable callable_;
  };

  return detail::build_generator<FromCallableGenerator>(std::move(callable));
}


template <typename Iterator>
auto generate(Iterator begin, Iterator end) ->
Generator<typename std::iterator_traits<Iterator>::value_type>
{
  using value_type = typename std::iterator_traits<Iterator>::value_type;

  class SequenceGenerator: public GeneratorBase<value_type> {
  public:
    SequenceGenerator(Iterator&& begin, Iterator&& end):
        it_(std::move(begin)), end_(std::move(end)) { }

    Maybe<value_type> next() final {
      return (it_ == end_)? Nothing : Just<value_type>(*it_++);
    }

  private:
    Iterator it_;
    const Iterator end_;
  };

  return detail::build_generator<SequenceGenerator>(std::move(begin), std::move(end));
}


template <typename Iterable>
auto generate(Iterable& iterable) ->
typename std::enable_if<
    is_iterable<Iterable>::value,
    decltype(generate(iterable.begin(), iterable.end()))
>::type
{
  return generate(iterable.begin(), iterable.end());
}

namespace detail {

template <typename ValueType>
struct generator_iterator_helper {
  using value_type = ValueType;
  using self_type = generator_iterator_helper;
  using generator_type = GeneratorBase<ValueType>;
  using generator_pointer = generator_type*;
  using reference = const value_type&;
  using pointer = const value_type*;
  using difference_type = std::ptrdiff_t;

  generator_iterator_helper() = default;

  generator_iterator_helper(generator_pointer generator):
      generator_(std::move(generator)) {
    next();
  }

  void next() {
    assert(!is_end());
    value_ = generator_->next();
    if (value_ == Nothing)
      generator_ = nullptr;
  }

  reference value() const { return value_.get(); }

  pointer ptr() const { return &value_.get(); }

  bool equal(const self_type& other) const {
    return (this == &other) || (is_end() && other.is_end());
  }

private:
  bool is_end() const {
    return generator_ == nullptr;
  }

  generator_pointer generator_;
  Maybe<value_type> value_;
};

template <typename ValueType>
using generator_iterator = input_iterator<detail::generator_iterator_helper<ValueType>>;

template <typename ValueType>
class generator_iterator_range {
public:
  using iterator_type = generator_iterator<ValueType>;

  explicit generator_iterator_range(Generator<ValueType>&& generator):
      generator_(std::move(generator)) { }

  iterator_type begin() const {
    return generator_iterator<ValueType>(generator_.get());
  }

  iterator_type end() const {
    return generator_iterator<ValueType>();
  }

private:
  Generator<ValueType> generator_;
};

template <typename Generator>
auto build_generator_iterator_range(Generator&& generator) ->
generator_iterator_range<typename Generator::element_type::value_type>
{
  return generator_iterator_range<typename Generator::element_type::value_type>(std::move(generator));
}

} 


template <typename GeneratorHandle>
auto iterate(GeneratorHandle&& generator) ->
typename std::enable_if<
    is_generator<GeneratorHandle>::value,
    decltype(detail::build_generator_iterator_range(std::move(generator)))
>::type
{
  return detail::build_generator_iterator_range(std::move(generator));
}


template <typename Generator, typename Callable>
auto iterate(Generator&& generator, Callable&& callable) ->
typename std::enable_if<
    is_generator<Generator>::value
>::type
{
  while (true) {
    auto elem = generator->next();
    if (elem == Nothing)
      break;
    callable(std::move(elem.get()));
  }
  generator.reset();
}


template <typename GeneratorHandle>
auto as_vector(GeneratorHandle&& generator) ->
typename std::enable_if<
    is_generator<GeneratorHandle>::value,
    std::vector<typename std::remove_reference<GeneratorHandle>::type::element_type::value_type>
>::type
{
  using value_type = typename std::remove_reference<GeneratorHandle>::type::element_type::value_type;
  auto range = iterate(generator);
  return std::vector<value_type>(range.begin(), range.end());
}


template <typename GeneratorHandle>
auto as_list(GeneratorHandle&& generator) ->
typename std::enable_if<
    is_generator<GeneratorHandle>::value,
    std::list<typename std::remove_reference<GeneratorHandle>::type::element_type::value_type>
>::type
{
  using value_type = typename std::remove_reference<GeneratorHandle>::type::element_type::value_type;
  auto range = iterate(generator);
  return std::list<value_type>(range.begin(), range.end());
}


template <typename GeneratorHandle>
auto as_set(GeneratorHandle&& generator) ->
typename std::enable_if<
    is_generator<GeneratorHandle>::value,
    std::set<typename std::remove_reference<GeneratorHandle>::type::element_type::value_type>
>::type
{
  using value_type = typename std::remove_reference<GeneratorHandle>::type::element_type::value_type;
  auto range = iterate(generator);
  return std::set<value_type>(range.begin(), range.end());
}


template <typename GeneratorHandle, typename Callable>
auto filter(GeneratorHandle&& generator, Callable predicate) ->
typename std::enable_if<
    is_generator<GeneratorHandle>::value,
    Generator<typename std::remove_reference<GeneratorHandle>::type::element_type::value_type>
>::type
{
  using value_type = typename std::remove_reference<GeneratorHandle>::type::element_type::value_type;

  return generate(
      std::bind([] (typename std::remove_reference<GeneratorHandle>::type& generator, Callable predicate) -> Maybe<value_type> {
                  while (true) {
                    auto elem = generator->next();
                    if (elem == Nothing)
                      return Nothing;
                    else if (predicate(elem.get()))
                      return std::move(elem);
                  }
                },
                std::move(generator),
                std::move(predicate)
      )
  );
}



template <typename GeneratorHandle, typename Callable>
auto map(GeneratorHandle&& generator, Callable callable) ->
typename std::enable_if<
    is_generator<GeneratorHandle>::value,
    Generator<decltype(callable(generator->next().get()))>
>::type
{
  using value_type = decltype(callable(generator->next().get()));

  return generate(
      std::bind([] (typename std::remove_reference<GeneratorHandle>::type& generator, Callable callable) -> Maybe<value_type> {
                  auto elem = generator->next();
                  return (elem == Nothing)? Nothing : Just<value_type>(callable(elem.get()));
                },
                std::move(generator),
                std::move(callable)
      )
  );
}

} 

namespace pcl {

namespace detail {

const int kSimpleFancyFlagID = std::ios_base::xalloc();

enum printing_type {
  simple_printing_type = 0,
  fancy_printing_type = 1
};

class delimiter_printer {
public:
  delimiter_printer(std::ostream& stream): first_(true) {
    fancy_ = (stream.iword(kSimpleFancyFlagID) == fancy_printing_type);
  }

  const char* prefix() {
    return fancy_? "(" : "";
  }

  const char* delimiter() {
    if (!first_) {
      return fancy_? ", " : " ";
    }
    else {
      first_ = false;
      return "";
    }
  }

  const char* postfix() {
    return fancy_? ")" : "";
  }

private:
  bool first_;
  bool fancy_;
};

template <typename T>
constexpr bool allow_print_operator() {
  return
      is_iterable<T>::value &&
      !std::is_same<T, std::string>::value &&
      !std::is_same<T, const char*>::value &&
      !std::is_same<typename std::remove_extent<T>::type, char>::value;
}

} 


std::ostream& simple(std::ostream& stream) {
  stream.iword(detail::kSimpleFancyFlagID) = detail::simple_printing_type;
  return stream;
}


std::ostream& fancy(std::ostream& stream) {
  stream.iword(detail::kSimpleFancyFlagID) = detail::fancy_printing_type;
  return stream;
}


template <typename T1, typename T2>
std::ostream& operator<<(std::ostream& stream, const std::pair<T1, T2>& pair);


template <typename... Args>
std::ostream& operator<<(std::ostream& stream, const std::tuple<Args...>& tuple);


template <typename Iterable>
typename std::enable_if<detail::allow_print_operator<Iterable>(), std::ostream&>::type
operator<<(std::ostream& stream, const Iterable& iterable);

#ifdef USE_INT128_TYPES


std::ostream& operator<<(std::ostream& stream, uint128 n) {
  constexpr int32 buffer_size = 64;
  constexpr uint128 ten = 10;
  char buffer[buffer_size];
  int32 index = buffer_size - 1;

  do {
    uint128 digit = n % 10;
    buffer[index--] = char('0' + digit);
    n /= 10;
  } while (n > 0 && index >= 0);

  stream.write(buffer + index + 1, buffer_size - index - 1);
  return stream;
}


std::ostream& operator<<(std::ostream& stream, int128 n) {
  if (n < 0) {
    stream.put('-');
    n = -n;
  }
  stream << uint128(n);
  return stream;
}

#endif


template <typename T1, typename T2>
std::istream& operator>>(std::istream& stream, std::pair<T1, T2>& pair);


template <typename... Args>
std::istream& operator>>(std::istream& stream, std::tuple<Args...>& tuple);


template <typename T>
struct ignore {
  ignore() = default;

  friend std::istream& operator>>(std::istream& stream, const ignore&&) {
    T ignored;
    return stream >> ignored;
  }

  friend std::istream& operator>>(std::istream& stream, const ignore&) {
    T ignored;
    return stream >> ignored;
  }
};

namespace detail {

template<std::size_t...>
struct integer_sequence{};

template <size_t N>
struct generate_sequence {
private:
  template<std::size_t M, std::size_t... Is>
  struct helper {
    using type = typename helper<M-1, M-1, Is...>::type;
  };;

  template<std::size_t... Is>
  struct helper<0, Is...> {
    using type = integer_sequence<Is...>;
  };

public:
  using type = typename helper<N>::type;
};

template <typename Functor, size_t N>
struct dynamize {
  using functor_type = Functor;
private:
  using index_sequence = typename generate_sequence<N>::type;
  using function_type = void(functor_type::*)();
  using table_type = std::array<function_type, N>;

  template <size_t... Indexes>
  static constexpr table_type build_table(integer_sequence<Indexes...>) {
    return {{&functor_type::template operator()<Indexes>...}};
  }

  static constexpr table_type functions_ = build_table(index_sequence());
public:
  dynamize(functor_type&& functor):
      functor_(std::move(functor)) { }

  void call(size_t i) {
    if (i >= N)
      throw std::out_of_range("tuple_printer: out of range");

    (functor_.*functions_[i])();
  }

private:
  functor_type functor_;
};

template <typename Functor, size_t N>
constexpr typename dynamize<Functor, N>::table_type dynamize<Functor, N>::functions_;

template <typename... Args>
class tuple_printer {
  static constexpr size_t arguments_count = sizeof...(Args);
  using tuple_type = std::tuple<Args...>;

  struct impl {
    std::ostream& stream_;
    const tuple_type& tuple_;

    template <size_t N>
    void operator()() {
      stream_ << std::get<N>(tuple_);
    }
  };

public:
  tuple_printer (std::ostream& stream, const tuple_type& tuple):
    dynamize_(impl{stream, tuple}) { }

  void print(size_t i) {
    dynamize_.call(i);
  }

private:
  dynamize<impl, arguments_count> dynamize_;
};

template <typename... Args>
class tuple_reader {
  static constexpr size_t arguments_count = sizeof...(Args);
  using tuple_type = std::tuple<Args...>;

  struct impl {
    std::istream& stream_;
    tuple_type& tuple_;

    template <size_t N>
    void operator()() {
      stream_ >> std::get<N>(tuple_);
    }
  };

public:
  tuple_reader (std::istream& stream, tuple_type& tuple):
      dynamize_(impl{stream, tuple}) { }

  void read(size_t i) {
    dynamize_.call(i);
  }

private:
  dynamize<impl, arguments_count> dynamize_;
};

} 

template <typename T1, typename T2>
std::ostream& operator<<(std::ostream& stream, const std::pair<T1, T2>& pair) {
  detail::delimiter_printer printer(stream);
  stream << printer.prefix();
  stream << printer.delimiter() << pair.first;
  stream << printer.delimiter() << pair.second;
  stream << printer.postfix();
  return stream;
}

template <typename... Args>
std::ostream& operator<<(std::ostream& stream, const std::tuple<Args...>& tuple) {
  detail::delimiter_printer delimiter_printer(stream);
  detail::tuple_printer<Args...> tuple_printer(stream, tuple);
  stream << delimiter_printer.prefix();
  for (auto i: range<size_t>(0, sizeof...(Args))) {
    stream << delimiter_printer.delimiter();
    tuple_printer.print(i);
  }
  stream << delimiter_printer.postfix();
  return stream;
}

template <typename Iterable>
typename std::enable_if<detail::allow_print_operator<Iterable>(), std::ostream&>::type
operator<<(std::ostream& stream, const Iterable& iterable) {
  detail::delimiter_printer printer(stream);
  stream << printer.prefix();
  for (const auto& elem: iterable) {
    stream << printer.delimiter() << elem;
  }
  stream << printer.postfix();
  return stream;
}

template <typename T1, typename T2>
std::istream& operator>>(std::istream& stream, std::pair<T1, T2>& pair) {
  return stream >> pair.first >> pair.second;
}

template <typename... Args>
std::istream& operator>>(std::istream& stream, std::tuple<Args...>& tuple) {
  detail::tuple_reader<Args...> tuple_reader(stream, tuple);
  for (auto i: range<size_t>(0, sizeof...(Args))) {
    tuple_reader.read(i);
  }
  return stream;
}



template <typename... Args>
std::istream& operator>>(std::istream& stream, std::tuple<Args...>&& tuple) {
  return stream >> tuple;
}


template <typename... Args>
void print(std::ostream& stream, const char* format, const Args&... args) {
  auto tuple = std::make_tuple(std::cref(args)...);
  detail::tuple_printer<const Args&...> tuple_printer(stream, tuple);
  constexpr char null = '\0';
  constexpr char percent = '%';
  for (const char* it = format, *prev = format; *it != '\0'; ) {
    while (*it != null && *it != percent)
      it++;

    stream.write(prev, it - prev);
    if (*it == percent) {
      ++it;
      if (*it == percent) {
        stream.put(percent);
      }
      else if (std::isdigit(*it)) {
        size_t index = size_t(*it - '0');
        tuple_printer.print(index);
      }
      else {
        throw std::invalid_argument("print - invalid character after %");
      }
      prev = ++it;
    }
  }
  stream.put('\n');
}


template <typename... Args>
void print(const char* format, const Args&... args) {
  print(std::cout, format, args...);
}


std::ostream& flush(std::ostream& stream) {
  return stream.flush();
}


std::ostream& newline(std::ostream& stream) {
  return stream.put('\n');
}


template <typename... Args>
void read(std::istream& stream, Args&&... args) {
  auto tuple = std::make_tuple(std::ref(args)...);
  stream >> tuple;
}


Generator<std::string> Lines(std::istream& stream) {
  return generate([&stream]() -> Maybe<std::string> {
    if (!stream.good())
      return Nothing;
    std::string line;
    std::getline(stream, line);
    return line;
  });
}


template <typename ValueType>
auto ReadSequence(std::istream& stream, uint32 count) ->
Generator<ValueType>
{
  class SequenceReader: public GeneratorBase<ValueType> {
  public:
    SequenceReader(std::istream& stream, uint32 count):
        stream_(stream), count_(count) { }

    Maybe<ValueType> next() final {
      if (count_ == 0)
        return Nothing;

      count_--;
      ValueType value;
      stream_ >> value;
      return Just<ValueType>(value);
    }

  private:
    std::istream& stream_;
    uint32 count_;
  };
  return detail::build_generator<SequenceReader>(stream, count);
}

} 





namespace pcl {
namespace text {


template <typename Iterator, typename Predicate>
std::vector<std::string> split(Iterator begin, Iterator end, Predicate predicate, bool includeEmpty = false) {
  std::vector<std::string> result;
  for (auto it = begin, prev = begin; ; ) {
    while (it != end && !predicate(*it))
      ++it;

    if (includeEmpty || prev != it)
      result.emplace_back(prev, it);

    if (it != end) {
      ++it;
      prev = it;
    }
    else {
      break;
    }
  }
  return result;
}


template <typename Iterator>
std::vector<std::string> split(Iterator begin, Iterator end, char c, bool includeEmpty = false) {
  auto predicate = [c](char d) {
    return c == d;
  };
  return split(begin, end, predicate, includeEmpty);
}


template <typename Iterator>
std::vector<std::string> split(Iterator begin, Iterator end, const char* chars, bool includeEmpty = false) {
  const char* const str_begin = chars;
  const char* const str_end = chars + strlen(chars);
  auto predicate = [str_begin, str_end](char c) {
    return std::find(str_begin, str_end, c) != str_end;
  };
  return split(begin, end, predicate, includeEmpty);
}


template <typename Iterator>
std::string join(std::string separator, Iterator begin, Iterator end) {
  size_t size = 0;
  for (const auto& str: make_range(begin, end))
    size += 1 + str.size();

  std::string result;
  result.reserve(size);

  bool first = true;
  for (const auto& str: make_range(begin, end)) {
    if (!first)
      result += separator;
    else
      first = false;

    result += str;
  }
  return result;
}


template <typename Iterator, typename Predicate>
std::string strip(Iterator begin, Iterator end, Predicate predicate) {
  while (begin != end && predicate(*begin))
    ++begin;

  while (begin != end && predicate(*std::prev(end)))
    --end;

  return std::string(begin, end);
}


template <typename Iterator>
std::string strip(Iterator begin, Iterator end, char c) {
  auto predicate = [c] (char d) {
    return c == d;
  };
  return strip(begin, end, predicate);
}


template <typename Iterator>
std::string strip(Iterator begin, Iterator end, const char* chars) {
  const char* const str_begin = chars;
  const char* const str_end = chars + strlen(chars);
  auto predicate = [str_begin, str_end](char c) {
    return std::find(str_begin, str_end, c) != str_end;
  };
  return strip(begin, end, predicate);
}


template <typename Iterator1, typename Iterator2>
bool starts_with(Iterator1 begin1, Iterator1 end1, Iterator2 begin2, Iterator2 end2) {
  for (auto elem: make_range(begin2, end2)) {
    if (begin1 == end1 || *begin1++ != elem)
      return false;
  }
  return true;
}


bool starts_with(const std::string text, const std::string& prefix) {
  return starts_with(text.begin(), text.end(), prefix.begin(), prefix.end());
}


bool starts_with(const std::string text, const char* prefix) {
  auto length = std::strlen(prefix);
  return starts_with(text.begin(), text.end(), prefix, prefix + length);
}


} 
} 

namespace pcl {
namespace logging {

enum class log_level {
  debug = 15,
  info = 10,
  error = 5,
  none = 0
};

const char* log_level_name(log_level level) {
  switch (level) {
    case log_level::debug:
      return "debug";
    case log_level::info:
      return "info";
    case log_level::error:
      return "error";
    case log_level::none:
      return "none";
  }
}

namespace detail {

std::string date_time_string() {
  std::ostringstream stream;
  std::time_t t = std::time(nullptr);
  std::tm tm = *std::localtime(&t);
  stream << std::put_time(&tm, "%d/%m/%y %T");
  return stream.str();
}

} 

class LogMaster {
public:
  friend LogMaster& log_master();

  
  void subscribe(std::string topic, log_level level, std::string format, std::ostream* stream) {
    subscriptions_.push_back({std::move(topic), level, std::move(format), stream});
  }

  
  void log(const std::string& topic, log_level level, const std::string& message) {
    for (const auto& subscription: subscriptions_) {
      
      
      
      if (level <= subscription.level &&
          text::starts_with(topic, subscription.topic)) {

        std::string log;
        for (auto c: subscription.format) {
          switch (c) {
            case 'T':
              log += '[';
              log += topic;
              log += "]\t";
              break;
            case 'L':
              log += '[';
              log += log_level_name(level);
              log += "]\t";
              break;
            case 'D':
              log += '[';
              log += detail::date_time_string();
              log += "]\t";
              break;
            default:
              continue;
          }
        }
        log += message;
        *subscription.stream << log << std::flush;
      }
    }
  }

private:
  LogMaster() = default;

  struct SubscriptionEntry {
    std::string topic;
    log_level level;
    std::string format;
    std::ostream* stream;
  };

  std::vector<SubscriptionEntry> subscriptions_;
};

LogMaster& log_master() {
  static LogMaster logMaster;
  return logMaster;
}

class Logger {
public:
  Logger(std::string topic):
      topic_(std::move(topic)) { }

  template <typename... Args>
  void log(log_level level, const char* format, const Args&... args) {
    std::ostringstream stream;
    print(stream, format, args...);
    log_master().log(topic_, level, stream.str());
  }

  template <typename... Args>
  void debug(const char* format, const Args&... args) {
    log(log_level::debug, format, args...);
  }

  template <typename... Args>
  void info(const char* format, const Args&... args) {
    log(log_level::info, format, args...);
  }

  template <typename... Args>
  void error(const char* format, const Args&... args) {
    log(log_level::error, format, args...);
  }

protected:
  Logger() = default;

private:
  std::string topic_;
};

} 
} 

using namespace pcl;

logging::Logger logger("main");

class Application {
public:
  Application() {

  }

  void Run(uint32 T) {
    std::vector<int64> v;
    while (N > 0) {
      v.push_back(N % 10);
      N /= 10;
    }

    for (auto i: range<uint32>(0, v.size() - 1)) {
      if (v[i+1] > v[i] && v[i + 1] > 0) {
        for (auto j: range<uint32>(0, i + 1)) {
          v[j] = 9;
        }
        v[i + 1]--;
      }
    }

    std::reverse(v.begin(), v.end());

    uint64 result = 0;
    for (auto k: v) {
      result *= 10;
      result += k;
    }
    print("Case #%0: %1", T + 1, result);
  }

  void LoadData() {
    read(std::cin, N);
  }

private:
  uint64 N;
};

int main(int argc, const char* argv[]) {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  std::cout.tie(nullptr);
  logging::log_master().subscribe("main", logging::log_level::debug, "L", &std::cerr);
  uint32 T;
  read(std::cin, T);
  for (auto t: range<uint32>(0, T)) {
    Application application;
    application.LoadData();
    application.Run(t);
  }
  return 0;
}
