/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author chang
 */


#include <cstdio>
#include <iostream>
#include <cassert>
#include <cctype>
#include <cfloat>
#include <climits>
#include <cstring>
#include <bitset>
#include <deque>
#include <map>
#include <set>
#include <stack>
#include <queue>
#include <vector>
#include <algorithm>
#include <string>

#include <cmath>
#include <fstream>
#include <iomanip>

using namespace std;


#define TRACE

#ifdef TRACE
template<class T, class U>
ostream& operator<<(ostream& out, const pair<T, U>& a) {out << "[" << a.first << " " << a.second << "]"; return out;}
template<class T>
ostream& operator<<(ostream& out, const vector<T>& a) {out << "[ "; for (auto &it : a)out << it << " "; out << "]"; return out;}
template<class T>
ostream& operator<<(ostream& out, const set<T>& a) {out << "[ "; for (auto &it : a)out << it << " "; out << "]"; return out;}
template<class T>
ostream& operator<<(ostream& out, const multiset<T>& a) {out << "[ "; for (auto &it : a)out << it << " "; out << "]"; return out;}
template<class T, class U>
ostream& operator<<(ostream& out, const map<T, U>& a) {for (auto &it : a)out << it.first << " -> " << it.second << " | "; return out;}
template<class T, class U>
ostream& operator<<(ostream& out, const multimap<T, U>& a) {for (auto &it : a)out << it.first << " -> " << it.second << " | "; return out;}

#else
#define pr(...)
#define pra(a,n)
#define praa(a,n,m)
#endif

#define FOR(i,a,b) for(int i=(a);i<=(b);++i)
#define TCASE(in) int __T;in>>__T;FOR(Tc,1,__T)
#define outprefix(tc) "Case #" << tc << ": "

const int ND = 20;

long long dp[ND][10][2],input;
bool vis[ND][10][2];
int n;

long long fp[ND];
class TidyNumbers {
public:
	void reset(long long cur){
		input = cur;
		for(n = 0; cur > 0; ++n) cur = cur/10;
		memset(vis,false, sizeof(vis));
	}

	long long f(int x,int prev,int tight){
		if (x < 0) return (prev != 0);
		if (vis[x][prev][tight]) return dp[x][prev][tight];

		vis[x][prev][tight] = true;
		long long ans = 0LL;
		if (tight) {
			int d = (input/fp[x])%10;
			for (int i = prev; i < d; ++i)
				ans += f(x-1,i,0);
			if (d >= prev)
				ans += f(x-1,d,1);
		}
		else {
			for(int i = prev; i < 10; ++i)
				ans += f(x-1,i,0);
		}

//		pr(x,prev,tight,ans);
		dp[x][prev][tight] = ans;
		return ans;
	}

	long long get(long long num){
		reset(num);
		return f(n-1,0,1);
	}

	void solve(std::istream& in, std::ostream& out) {
		fp[0] = 1LL;
		for(int i = 1; i <= 18; ++i) fp[i] = 10LL*fp[i-1];

		TCASE(in){
			long long num;
			in >> num;

			long long st = 0LL, en = num;
			long long ans = -1LL;

			long long req = get(num);
			while(st <= en){
				long long mid = (st+en)/2LL;
				long long val = get(mid);

//				pr(st,en,mid,val,req);
				if (val >= req){
					ans = mid;
					en = mid-1;
				} else
					st = mid+1;
			}

			out << outprefix(Tc) << ans << "\n";
		}
	}
};


int main() {
	TidyNumbers solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
