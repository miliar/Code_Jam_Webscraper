import sys
import re
import string

#some handy regex compile defs
number_pattern = re.compile(r"([0-9]+)")

def readnumber(stringinput):
		try:
			Num = number_pattern.search(stringinput).group(1)
			Num = int(Num)
			return Num
	
		except:
			print 'Error:', stringinput,'Not a number'
			return None

def FindMinSwitch(states,queryseq):
	#To find the minimum number of switches required, I look at this problem
	#as a simple Hidden Markov Model. The sequence of queries are the outputs
	#of the system and each state represents one of the search engines.
	#In this view, each query could have been generated by either one the
	#states (search engines) constrained by a cost function.
	#This cost function is 1 if query is not the same as the search engine name
	#                      2000 if query is the same as search engine name
	#                      (we say 2000 because 2000 is bigger than the max
	#				number of switches possible in the big set, this way
	#				we rule out paths that send querys to search engines
	#				that have the same name)
	def cost_function(q):
		try:
			disallowed_searche = states.index(q)
			cost = [0 for i in range(len(states))]
			cost[disallowed_searche] = 2000
		except:
			print 'query not the name of a search engine skipping query'
			cost = [0 for i in range(len(states))]
		return cost

	#Next, the transition matrix depicts the cost of going from one 
	#state to another.
	#The cost is zero if you don't change states (i.e. staying with the same 
	#search engine for multiple queries) or 1 if you change (i.e. switching
	#search engines)
	transition_matrix = []
	for i in range(len(states)):
		temp = []
		for j in range(len(states)):
			if j == i:
				temp = temp + [0]
			else:
				temp = temp + [1]
		transition_matrix = transition_matrix + [temp]

	for i in range(len(transition_matrix)):		
		print transition_matrix[i]

	#We then use a variation of the Forward-Backwards algorithm (Non greedy)to find the 
	#minimum cost of decoding the whole query sequence.
	#we store the switching cost of being in each state during the
	#query sequence in numswitchmatrix.
	numswitchmatrix = []

	#first initializing the numswitchmatirx
	first_query = queryseq.pop()
	numswitchmatrix = numswitchmatrix + [cost_function(first_query)]
	#print 'init numswitchmatrix:',numswitchmatrix

	#at this point, we move from one query to the next, and for each query term, we find
	#what is the minimum costly (in terms of switching between search engines) path from
	#the previous query term to arrive at each state
	while queryseq:
		query = queryseq.pop()
		cost = cost_function(query)
		print query,cost
		current_temp = []
		for statenum in range(len(states)):
			#cost_from_different_paths is a list containing the cost of arriving to states[statenum] 
			#from each state from the previous query
			cost_from_different_paths = [(cost[statenum]+transition_matrix[statenum][i]+numswitchmatrix[-1][i]) for i in range(len(states))]
			print "cost_from_different_paths",cost_from_different_paths
			#we take note of the minimum costly path of arriving at states[statenum] when working with the current query
			current_temp = current_temp + [min(cost_from_different_paths)]

		numswitchmatrix = numswitchmatrix + [current_temp]
	#print numswitchmatrix
	# minimum of last element  of numswitchmatrix is the minimum possible number of search engine switches
	return min(numswitchmatrix[-1])

if len(sys.argv) != 3:
	print "Usage: python MinSwtich.py inputfile outputfile"

elif len(sys.argv) == 3:

	#first reading the input file:
	inputfile = file (sys.argv[1],'r')
	inputall = inputfile.readlines()
	inputfile.close()
	#cursor holds the line number we are working with in different times
	cursor = 0


	#Next finding and store the number of cases
	NumCases = readnumber(inputall[cursor])
	print 'NumCases:',NumCases
	cursor +=1

	#CaseNumber shows the case we are handling currently
	CaseNumber = 1
	
	#We will put all the output in a list and at the end put it all in a file
	output = []

	while NumCases:
		NumCases -= 1
		#Finding the number of search engines (states) in this case
		NumSearche = readnumber(inputall[cursor])
		
		#storing the searchengine's names from lines cursor+1 to cursor+NumSearche
		searchengs = []
		for i in range(cursor+1,cursor+NumSearche+1):
			searchengs = searchengs + [inputall[i][:-1]]
		print "searchengs:" , searchengs

		#finding the number of queries
		cursor = cursor + NumSearche+1
		NumQ = readnumber(inputall[cursor])

		querylist = []
		for i in range(cursor+1,cursor+NumQ+1):
			querylist = querylist + [inputall[i][:-1]]

		print 'query seq:',querylist

		#we now use FindMinSwitch to find the min switches required to handle the
		#queries
		if querylist:
			Y = FindMinSwitch(searchengs,querylist)
			print CaseNumber,':',Y
			output = output + ['Case #'+str(CaseNumber)+': '+str(Y)]
		else:
			output = output + ['Case #'+str(CaseNumber)+': 0']

		CaseNumber  += 1
		cursor += 1 + NumQ
	
	#outputing to a file
	outputfile = file(sys.argv[2],'w')
	for o in output:
		outputfile.write(o+'\n')
	outputfile.close()

	
