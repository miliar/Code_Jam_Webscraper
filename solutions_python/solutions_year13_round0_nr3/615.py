#!/usr/bin/env python


import math


#
# Fair and Square Number List Generation
#

# Palindromic number indicator function
# Helper function for the fair and square number list generator
def isPalindrome( num ):
   strValue = str( num )
   return strValue == strValue[ : : -1 ]

# Fair and square number list generator function
# If we pregenerate the list, we spend some time at the start but we'll save
# time when handling each test case. Another time saver will be to copy the
# generated list straight into the source code provided that the list is not
# too large.
def fairAndSquareList( maxDigits ):
   # 1-digit fair and square numbers. Note that there are no 2-digit fair and
   # square numbers because none of the 2-digit perfect square numbers are
   # palindromic.
   masterList = [ 1L, 4L, 9L ]
   if maxDigits < 3:
      return masterList
   # For 3-digits or more, we use a different approach. If the number of digits
   # is odd, we establish a middle digit first. Then, regardless of whether the
   # digit count is odd or even, we iterate over possible digits on one side and
   # then mirror those digits on the other side to create palindromes.
   for numDigits in range( 3, maxDigits + 1 ):
      if numDigits % 2 == 1:
         # odd count: middle digit needed
         midDigits = [ "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ]
         countOneSide = ( numDigits - 1 ) / 2
      else:
         # even count: no middle digit needed
         midDigits = [ "" ]
         countOneSide = numDigits / 2
      # Iterate through the acceptable combinations of side digits.
      start = long( 10 ) ** long( countOneSide - 1 )
      end = long( 10 ) * start
      i = start
      while i < end:
         # Iterate through the possible choices for the middle digit. The middle
         # digit is blank for an even total digit count, though.
         for mid in midDigits:
            left = str( i )
            right = left[ : : -1 ]
            strValue = left + mid + right
            numValue = long( strValue )
            # Filter out palindromes that aren't perfect squares.
            squareRoot = math.sqrt( numValue )
            if squareRoot != math.floor( squareRoot ):
               continue
            # Add to the master list the square palindromes whose square roots
            # are also palindromes.
            if isPalindrome( long( squareRoot ) ):
               masterList.append( numValue )
         i += 1
   return masterList


#
# The Actual Fair and Square Number Master List for Interval [ 1, 10 ** 14 ]
#

# Okay, this may seem like a cheat but this list was actually generated by the
# functions above. The generated list was just pasted here as part of the source
# code because the list has a reasonably small size and because this saves time.
# On my computer, it took around 45 seconds to generate the list below.
masterList = [
   1L, 4L, 9L, 121L, 484L, 10201L, 12321L, 14641L, 40804L, 44944L, 1002001L,
   1234321L, 4008004L, 100020001L, 102030201L, 104060401L, 121242121L,
   123454321L, 125686521L, 400080004L, 404090404L, 10000200001L, 10221412201L,
   12102420121L, 12345654321L, 40000800004L, 1000002000001L, 1002003002001L,
   1004006004001L, 1020304030201L, 1022325232201L, 1024348434201L,
   1210024200121L, 1212225222121L, 1214428244121L, 1232346432321L,
   1234567654321L, 4000008000004L, 4004009004004L
   ]


#
# Fair and Square Number Counter Function
#

def fairAndSquareCount( masterList, lowerBound, upperBound ):
   count = 0
   for entry in masterList:
      if ( entry >= lowerBound ) and ( entry <= upperBound ):
         count += 1
      elif entry > upperBound:
         break
   return count


#
# Main Function
#

if __name__ == "__main__":
   # Master list generation (results integrated with source code to save time)
   #masterList = fairAndSquareList( 14 )
   #print "masterList = %s" % masterList
   # Solving the test cases
   T = int( raw_input() )
   for i in range( 0, T ):
      line = raw_input()
      bounds = line.split()
      lowerBound = int( bounds[ 0 ] )
      upperBound = int( bounds[ 1 ] )
      count = fairAndSquareCount( masterList, lowerBound , upperBound )
      print "Case #%d: %d" % ( i + 1, count )
