import os
import sys
import math
import itertools

# Haven't actually gotten this stuff working yet
def next_palindrome(num):
	srep = list("%s" % num)
	for x in range(len(srep)/2):
		srep[-1 - x] = srep[x]
	# Increment the digits in the middle
	return  int(''.join(srep))

# Not yet finished. Maybe not even necessary?
def gen_palindromes(num):
	# Assumes the input is safe!
	# Break in half
	#12321 -> only interested in the 123
	srep = "%s" % num
	# Include the last digit in the reflection?
	even = False
	if len(srep) % 2 == 0:
		even = True
		srep = srep[0:len(srep)/2]
	else:
		srep = srep[0:1+len(srep)/2]
	if even:
		pass


def is_palindrome2(digits):
	for x in range(len(digits)/2):
		if digits[x] != digits[-1-x]:
			return False
	return True

def is_palindrome(num):
	return is_palindrome2("%s" % num)

#fairsquare_1k = []
#for x in range(100):
#	if is_palindrome(x) and is_palindrome(x*x):
#		fairsquare_1k.append(x*x)

#fairsquare_14k = [] # yes, 14k is a stupid name for this
#for x in range(10000000): # sqrt(10^14)
#	if is_palindrome(x) and is_palindrome(x*x):
#		fairsquare_14k.append(x*x)

# Maybe this is slightly dodgy... pre-generated by the above. Only took about 30s anyway:
fairsquare_14k = [0, 1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001,
		102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001L, 10221412201L,
		12102420121L, 12345654321L, 40000800004L, 1000002000001L, 1002003002001L, 1004006004001L,
		1020304030201L, 1022325232201L, 1024348434201L, 1210024200121L, 1212225222121L, 1214428244121L,
		1232346432321L, 1234567654321L, 4000008000004L, 4004009004004L]

entries = int(sys.stdin.readline())

case = 1
for case in range(1, entries + 1):
	a, b = sys.stdin.readline().strip().split()
	a = int(a)
	b = int(b)
	count = len(filter(lambda x: x >= a and x <= b, fairsquare_14k))
	print "Case #%s: %s" % (case, count)

