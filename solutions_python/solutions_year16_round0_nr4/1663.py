# -*- coding: utf-8 -*-
"""
 
@author: Luca
"""

# General imports
#import numpy as np
#import scipy as sc
#import itertools
import sys

def read_word(f):
    return next(f).strip()

def read_int(f, b=10):
    return int(read_word(f), b)

def read_letters(f):
    return list(read_word(f))

def read_digits(f, b=10):
    return [int(x, b) for x in read_letters(f)]

def read_words(f, d=' '):
    return read_word(f).split(d)

def read_ints(f, b=10, d=' '):
    return [int(x, b) for x in read_words(f, d)]

def read_floats(f, d=' '):
    return [float(x) for x in read_words(f, d)]

def read_arr(f, R, reader=read_ints, *args, **kwargs):
    return [reader(f, *args, **kwargs) for i in range(R)]


    
def main_reader(T,f):
    K,C,S= read_ints(f)
    return {'T':T,'K':K,'C':C,'S':S}    


def enumeration_solver(T,K=None,C=None,S=None):
   """
   Transformation implies that tile at position i will generate
   a sequence of tiles that will begin at position 
   (i-1)*K^(C-1) + 1 when reaching complexity C
   if indices start on 1. It wifll be sufficient to test each
   beginning tile of the sequences generated by each initial tile
   to make sure there is at least one G tile in the original sequence.
   For small dataset since S=K solution is always possible.
   """
   tests = []     
   for i in range(1,K+1):
       tests.append((i-1)*K**(C-1)+1)
   return 'Case #%d: %s\n'%(T,' '.join([str(t) for t in tests]))
   
if __name__ == '__main__':

    do_debug = True
    input_file = sys.argv[1]
    output_file =  input_file.split('.')[0]+'.out'    
    
    try:
      with open(input_file,'r') as f:
          T = read_int(f) # Number of test cases
          for t in range(1, T+1):
              sys.stdout.write(enumeration_solver(**main_reader(t,f)))
    except IOError:
       print 'File %s not found'%input_file
       exit(1)       

