#!/usr/bin/python

import itertools
import sys

def generate(generator,C):
  Gs = 'G' * len(generator)
  answer = 'L'
  for i in xrange(C):
    answer = ''.join([(Gs if c == 'G' else generator) for c in answer])
  return answer

# K = length of generator
# C = complexity = number of generations
# S = max number of revelations
# Find S positions such that, if there's any G, it's in one of those positions.
def naive0(K,C,S):
  verboseLevel = 0
  if verboseLevel >= 1: print "    K=%s C=%s S=%s" % (K,C,S)
  K_to_power_C = K**C
  for s in xrange(S+1):
    if verboseLevel >= 1: print "        s=%s" % s
    for positions in itertools.combinations(range(K_to_power_C), s):
      if verboseLevel >= 1: print "            positions="+`positions`
      positions_are_good_for_all_generators_so_far = True
      for generator in itertools.product(['L','G'], repeat=K):
        if 'G' not in generator:
          continue # this one's not interesting
        generator = ''.join(generator)
        if verboseLevel >= 1: print "                generator="+`generator`
        generated = generate(generator,C)
        if verboseLevel >= 1: print "                generated="+`generated`
        positions_are_good_for_this_generator = False
        for i in xrange(s):
          if generated[positions[i]] == 'G':
            if verboseLevel >= 1: print "                    these positions are good for this generator"
            positions_are_good_for_this_generator = True
            break
        if not positions_are_good_for_this_generator:
          if verboseLevel >= 1: print "                these positions are bad for this generator"
          positions_are_good_for_all_generators_so_far = False
          break
      if positions_are_good_for_all_generators_so_far:
        if verboseLevel >= 1: print "            these positions are good for all generators!"
        return list(positions)
  return None

def answerToString(answer):
  if answer is None: return 'IMPOSSIBLE'
  return ' '.join([`x+1` for x in answer])


# Okay, let's think about this.
# We're looking for <= S positions such that
# every pattern generated by a generator of size K,
# of complexity C, with any gold in it, has gold in one of those positions.
# Observation: it suffices to consider only generators with exactly one 'G'.
#
# Examples:
#
#   K=1 -> minC=1
#       L -> G -> G -> G
#            ^
#
#   K=2 -> minC=2
#       L -> GL -> GG GL -> GG GG  GG GL -> GG GG  GG GG   GG GG  GG GL
#       L -> LG -> LG GG -> LG GG  GG GG -> LG GG  GG GG   GG GG  GG GG
#                   1 ^
#   K=3 -> minC=3
#       L -> GLL -> GGG GLL GLL -> GGG GGG GGG  GGG GLL GLL  GGG GLL GLL -> GGG GGG GGG  GGG GGG GGG  GGG GGG GGG   GGG GGG GGG  GGG GLL GLL  GGG GLL GLL   GGG GGG GGG  GGG GLL GLL  GGG GLL GLL
#       L -> LGL -> LGL GGG LGL -> LGL GGG LGL  GGG GGG GGG  LGL GGG LGL -> LGL GGG LGL  GGG GGG GGG  LGL GGG LGL   GGG GGG GGG  GGG GGG GGG  GGG GGG GGG   LGL GGG LGL  GGG GGG GGG  LGL GGG LGL
#       L -> LLG -> LLG LLG GGG -> LLG LLG GGG  LLG LLG GGG  GGG GGG GGG -> LLG LLG GGG  LLG LLG GGG  GGG GGG GGG   LLG LLG GGG  LLG LLG GGG  GGG GGG GGG   GGG GGG GGG  GGG GGG GGG  GGG GGG GGG
#                   2     2              1  ^     ^     ^     ^  ^
#   K=4 ->
#       L -> GLLL -> GGGG GLLL GLLL GLLL -> GGGG GGGG GGGG GGGG  GGGG GLLL GLLL GLLL  GGGG GLLL GLLL GLLL  GGGG GLLL GLLL GLLL -> GGGG GGGG GGGG GGGG  GGGG GGGG GGGG GGGG  GGGG GGGG GGGG GGGG  GGGG GGGG GGGG GGGG   GGGG GGGG GGGG GGGG  GGGG GLLL GLLL GLLL  GGGG GLLL GLLL GLLL  GGGG GLLL GLLL GLLL   GGGG GGGG GGGG GGGG  GGGG GLLL GLLL GLLL  GGGG GLLL GLLL GLLL  GGGG GLLL GLLL GLLL   GGGG GGGG GGGG GGGG  GGGG GLLL GLLL GLLL  GGGG GLLL GLLL GLLL  GGGG GLLL GLLL GLLL
#       L -> LGLL -> LGLL GGGG LGLL LGLL -> LGLL GGGG LGLL LGLL  GGGG GGGG GGGG GGGG  LGLL GGGG LGLL LGLL  LGLL GGGG LGLL LGLL -> LGLL GGGG LGLL LGLL  GGGG GGGG GGGG GGGG  LGLL GGGG LGLL LGLL  LGLL GGGG LGLL LGLL   GGGG GGGG GGGG GGGG  GGGG GGGG GGGG GGGG  GGGG GGGG GGGG GGGG  GGGG GGGG GGGG GGGG   LGLL GGGG LGLL LGLL  GGGG GGGG GGGG GGGG  LGLL GGGG LGLL LGLL  LGLL GGGG LGLL LGLL   LGLL GGGG LGLL LGLL  GGGG GGGG GGGG GGGG  LGLL GGGG LGLL LGLL  LGLL GGGG LGLL LGLL
#       L -> LLGL -> LLGL LLGL GGGG LLGL -> LLGL LLGL GGGG LLGL  LLGL LLGL GGGG LLGL  GGGG GGGG GGGG GGGG  LLGL LLGL GGGG LLGL -> LLGL LLGL GGGG LLGL  LLGL LLGL GGGG LLGL  GGGG GGGG GGGG GGGG  LLGL LLGL GGGG LLGL   LLGL LLGL GGGG LLGL  LLGL LLGL GGGG LLGL  GGGG GGGG GGGG GGGG  LLGL LLGL GGGG LLGL   GGGG GGGG GGGG GGGG  GGGG GGGG GGGG GGGG  GGGG GGGG GGGG GGGG  GGGG GGGG GGGG GGGG   LLGL LLGL GGGG LLGL  LLGL LLGL GGGG LLGL  GGGG GGGG GGGG GGGG  LLGL LLGL GGGG LLGL
#       L -> LLLG -> LLLG LLLG LLLG GGGG -> LLLG LLLG LLLG GGGG  LLLG LLLG LLLG GGGG  LLLG LLLG LLLG GGGG  GGGG GGGG GGGG GGGG -> LLLG LLLG LLLG GGGG  LLLG LLLG LLLG GGGG  LLLG LLLG LLLG GGGG  GGGG GGGG GGGG GGGG   LLLG LLLG LLLG GGGG  LLLG LLLG LLLG GGGG  LLLG LLLG LLLG GGGG  GGGG GGGG GGGG GGGG   LLLG LLLG LLLG GGGG  LLLG LLLG LLLG GGGG  LLLG LLLG LLLG GGGG  GGGG GGGG GGGG GGGG   GGGG GGGG GGGG GGGG  GGGG GGGG GGGG GGGG  GGGG GGGG GGGG GGGG  GGGG GGGG GGGG GGGG
#                       2   2                                                                                                                                       1   ^           ^       ^           ^   ^                       ^   ^                           ^           ^       ^       ^                   ^       ^       ^           ^                           ^   ^                       ^   ^           ^       ^           ^   ^                       
#   K=5 ->
#       L -> GLLLL -> GGGGG GLLLL GLLLL GLLLL GLLLL -> GGGGG GGGGG GGGGG GGGGG GGGGG  GGGGG GLLLL GLLLL GLLLL GLLLL  GGGGG GLLLL GLLLL GLLLL GLLLL  GGGGG GLLLL GLLLL GLLLL GLLLL  GGGGG GLLLL GLLLL GLLLL GLLLL
#       L -> LGLLL -> LGLLL GGGGG LGLLL LGLLL LGLLL -> LGLLL GGGGG LGLLL LGLLL LGLLL  GGGGG GGGGG GGGGG GGGGG GGGGG  LGLLL GGGGG LGLLL LGLLL LGLLL  LGLLL GGGGG LGLLL LGLLL LGLLL  LGLLL GGGGG LGLLL LGLLL LGLLL
#       L -> LLGLL -> LLGLL LLGLL GGGGG LLGLL LLGLL -> LLGLL LLGLL GGGGG LLGLL LLGLL  LLGLL LLGLL GGGGG LLGLL LLGLL  GGGGG GGGGG GGGGG GGGGG GGGGG  LLGLL LLGLL GGGGG LLGLL LLGLL  LLGLL LLGLL GGGGG LLGLL LLGLL
#       L -> LLLGL -> LLLGL LLLGL LLLGL GGGGG LLLGL -> LLLGL LLLGL LLLGL GGGGG LLLGL  LLLGL LLLGL LLLGL GGGGG LLLGL  LLLGL LLLGL LLLGL GGGGG LLLGL  GGGGG GGGGG GGGGG GGGGG GGGGG  LLLGL LLLGL LLLGL GGGGG LLLGL
#       L -> LLLLG -> LLLLG LLLLG LLLLG LLLLG GGGGG -> LLLLG LLLLG LLLLG LLLLG GGGGG  LLLLG LLLLG LLLLG LLLLG GGGGG  LLLLG LLLLG LLLLG LLLLG GGGGG  LLLLG LLLLG LLLLG LLLLG GGGGG  GGGGG GGGGG GGGGG GGGGG GGGGG
#                     3       3             3           2                                                                                  2
#
# Observation: for the small dataset, S=K, so it can always be solved by the positions 0..K-1 (output 1..K).
# Observation: if K,C can be done with S=1, then so can all greater C's.
# Observation: for given K, the first C that can be done with S=1 is C=K.
# Observation: for given K, the first position that works for C=K also works for all greater C.
# General strategy for C<K:
#       - there are at most C G's in any column.
#         candidate columns will be those with exactly C G's in them.
#       - if S*C < K, it's impossible.
#       - choose a set of S columns whose logical OR (where G=true and L=false) is all true's.

def div_rounding_up(a,b):
  return (a+b-1)//b
# numeral is big endian
def numeralToNumber(numeral, base):
  answer = 0
  for digit in numeral:
    answer = answer * base + digit
  #print "numeral="+`numeral`+" base="+`base`+" -> number="+`answer`
  return answer

def smart0(K,C,S):
  assert K >= 1
  assert C >= 1
  assert S >= 1
  s = div_rounding_up(K, C)
  if s > S:
    return None
  # To get the lexicographically first answer,
  # first decide the partitioning
  # of the rows into s parts of size at most C.
  # All but the first should have size exactly C.
  firstPartSize = K - (s-1)*C
  assert firstPartSize >= 1
  assert firstPartSize <= C
  parts = []
  for i in xrange(s):
    if i == 0:
      part = range(firstPartSize)
    else:
      part = range(firstPartSize+(i-1)*C, firstPartSize+i*C)
    parts.append(part)
  assert sum(parts, []) == range(K)
  #print "    parts = "+`parts`
  answer = []
  for part in parts:
    # What's the first column with G's in at least the rows specified in part?
    # I'm pretty sure it's the column with G's in *exactly* those rows.
    # Example:
    #         K=5 C=3 -> S=2, parts=[[0,1],[2,3,4]], indices=01, 234 (in base 5).
    # Ha, I think that's it!
    # Just interpret the parts as numerals in base K, big endian.
    numeral = part
    column = numeralToNumber(numeral, K)
    answer.append(column)
  return answer

def test(maxmax):
  for maxKCS in xrange(maxmax+1):
    for K in xrange(1, maxKCS+1):
      for C in xrange(1, maxKCS+1):
        for S in xrange(1, maxKCS+1):
          if max(K,C,S) != maxKCS:
            continue
          answerSmart0 = smart0(K,C,S)
          answerNaive0 = naive0(K,C,S)
          print "K=%s C=%s S=%s -> smart0=%s naive0=%s" % (K,C,S,answerToString(answerSmart0),answerToString(answerNaive0))
          assert answerNaive0 == answerSmart0

if len(sys.argv) >= 2:
  maxmax = int(sys.argv[1])
  test(maxmax)
else:
  line = sys.stdin.readline().strip()
  nInputs = int(line)
  #print "    nInputs = "+`nInputs`
  for iInput in xrange(nInputs):
    line = sys.stdin.readline().strip()
    #print "        line = "+`line`
    K,C,S = [int(x) for x in line.split()]
    answerSmart0 = smart0(K,C,S)
    print "Case #%s: %s" % (iInput+1, answerToString(answerSmart0))
    if K <= 4 and C <= 4 and S <= 4:
      answerNaive0 = naive0(K,C,S)
      assert answerNaive0 == answerSmart0
