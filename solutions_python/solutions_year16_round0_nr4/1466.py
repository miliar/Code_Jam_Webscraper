# 0 is lead, 1 is gold
# rules: take an example to show K = 4, C = 3
# 0000000000000000000000000000000000000000000000000000000000000000
# 0001000100011111000100010001111100010001000111111111111111111111
# 0010001011110010001000101111001011111111111111110010001011110010
# 0011001111111111001100111111111111111111111111111111111111111111
# 0100111101000100111111111111111101001111010001000100111101000100
# 0101111101011111111111111111111101011111010111111111111111111111
# 0110111111110110111111111111111111111111111111110110111111110110
# 0111111111111111111111111111111111111111111111111111111111111111
# 1111111111111111111110001000100011111000100010001111100010001000
# 1111111111111111111110011001111111111001100111111111111111111111
# 1111111111111111111110101111101011111111111111111111101011111010
# 1111111111111111111110111111111111111111111111111111111111111111
# 1111111111111111111111111111111111111111110011001111111111001100
# 1111111111111111111111111111111111111111110111111111111111111111
# 1111111111111111111111111111111111111111111111111111111111111110
# 1111111111111111111111111111111111111111111111111111111111111111

# matrix is 2^K * K^C
# make K-1 groups, boundaries has 2^(K-1) '0's, others has 2^(K-2) '0's
# thus clean first of each group (exclusive boundaries) will give correct answer for the small case S=K

# only for small sample S=K

t = input()  # read a line with a single longeger
for i in range(1, t + 1):
  K,C,S = [int(s) for s in raw_input().split(" ")]  # read a list of integers, 2 in this case
  
  if K==0:
    o = 'IMPOSSIBLE'
  elif C==1:
    o = ' '.join(map(str, range(1,K+1)))
  elif K==1:
    o = str(1)
  else:
    num_groups = K-1
    interval = (K**C-1)/num_groups
    o = ' '.join(map(str, range(2, K**C, interval)))

  print("Case #{}: {}".format(i, o))
