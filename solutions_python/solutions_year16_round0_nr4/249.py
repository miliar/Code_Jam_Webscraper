# Let's get our grad students gold hunting!

import fileinput
import math

# For the complicated case, this is unused.
def pick_tiles_simple(number_tiles, complexity):
    """
    Assumes I have at least as many students as tiles and determines which
    tiles the students should look at to see if the fractile has gold.
    
    param: number_tiles, the number of tiles in the original fractile
    param: complexity, the number of repetitions of the original fractile
           (with pattern based on lead-gold rules)
    return: a list of positions of tiles to clean off to look for gold
    """
    
    tile_indices = [i*number_tiles**(complexity-1) + 1
                    for i in range(number_tiles )]
    return tile_indices

def minimum_students_needed(tiles_K, complexity_C):
    """
    Determines the minimum number of students needed to definitely find gold in
    a fractile of a given complexity generated by a set number of tiles.
    
    param: tiles_K , the number of tiles generating the fractile
    param: complexity_C, the complexity of the fractile.
    return: the minimum students needed to solve the problem.
    """
    return int(math.ceil(tiles_K/complexity_C))

def is_possible(tiles_K, complexity_C, students):
    """
    It is possible to find a good set of indices if there are at least as many
    grad students as (number tiles)/(complexity).
    
    param: tiles_K, the number of tiles in the original, complexity=1 fractile
    param: complexity_C, the complexity of the fractile
    param: students, a positive integer number of students
    """
    #This likely doesn't need the ceil/int... worried about float errors
    return  minimum_students_needed(tiles_K, complexity_C) <= students

def find_good_indices(tiles_K, complexity_C, students):
    """
    Finds a list of good indices to search.
    
    param: tiles_K, the number of tiles in the original, complexity=1 fractile
    param: complexity_C, the complexity of the fractile
    param: students, a positive integer number of students
    return: a list of good indices to search for gold (see comments below for
            derivation information)
    precond: is_possible returns true
    """
    indices = []
    tiles_complete = 0
    indices_needed = min(students,
                         minimum_students_needed(tiles_K, complexity_C))
    for tile_set in range(indices_needed):
        # In short: for the first index, look in the first block of size
        # K^(C-1), and the second block of size K^(C-2) in it, and the third
        #block of size K^(C-3) in that, and so on until the bottom complexity
        # is reached.
        # For the second index, look in the (C+1)th block of size K^(C-1), and
        # within that the (C+2)th block of size K^(C-2), etc.
        index = 0
        for i in range(complexity_C):
            # If we are doing overkill, stop before we run off the edge.
            if tiles_complete == tiles_K:
                break
            
            index += (tile_set*complexity_C + i)*tiles_K**(complexity_C - i - 1)
            tiles_complete += 1
        
        indices.append(index+1) # Answer should be one-indexed, these are 0-indexed.
    return indices

def main():
    firstLine = True
    case = 1
    for line in fileinput.input():
        if firstLine:
            firstLine = False
            continue

        [tiles, complexity, students] = [int(num) for num in line.split()]
        
        print('CASE #' + str(case) + ': ', end='')
        if is_possible(tiles, complexity, students):
            indices = find_good_indices(tiles, complexity, students)
            for index in indices:
                print(index, end=' ')
            print()
        else:
            print('IMPOSSIBLE')
        case += 1


if __name__ == "__main__":
    main()
